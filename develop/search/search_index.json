{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"DarkMAGIC","text":"<p>The Dark Matter Ab initio phonon/maGnon Interaction Calculator (DarkMAGIC) is a python package for calculating dark matter interaction rates with phonons and magnons in real materials, based on properties calculated from first principles (mainly, density functional theory). It is based on the effective field theory developed by Trickle, Zhang and Zurek, and takes inspiration from the code they released with that paper, PhonoDark. </p> <p>DarkMAGIC is currently in pre-alpha testing, so not all features are implemented and not everything has been tested. Development is in progress, and once at a satisfying stage, a manuscript will be prepared.</p>"},{"location":"#features","title":"Features","text":"<ul> <li>Calculate scattering rates from single phonons and magnons.</li> <li>Supports phonon calculations using the frozen cell method or density functional perturbation theory with arbitrary DFT codes, based on the interface with phonopy.</li> <li>Supports toy models and ab initio-based spin hamiltonians via rad-tools and TB2J.</li> <li>Parallelized with MPI, and extremely performant.</li> <li>Easy to use Python API, with multiple pre-defined benchmark models.</li> <li>Portable HDF5 output format that allows the reconstruction of calculation as python objects. DarkMAGIC can also read and write HDF5 files in the format used by PhonoDark, but with limited functionality since it does not include all the parameters necessary to rebuild a calculation.</li> </ul>"},{"location":"#planned-features-short-term","title":"Planned Features (short term)","text":"<ul> <li>In principle, all operators in the EFT paper are implemented for phonons, but only spin-independent operators are currently functional due to a recent refactoring. Only the magnetic dipole and anapole models for magnons are currently implemented. This will be dealt with soon.</li> <li>JIT compilation for increased performance.</li> <li>Command line interface.</li> <li>Further post-processing and plotting tools.</li> <li>More documentation and examples. This website contains extensive, automatically-generated documentation for the python API.</li> </ul>"},{"location":"#planned-features-long-term","title":"Planned Features (long term)","text":"<ul> <li>Multi-phonon processes</li> <li>Absorption</li> <li>Support for fully first-principles time-dependent DFT magnon calculations instead of just spin Hamiltonians.</li> </ul>"},{"location":"examples/","title":"Examples","text":"<p>More examples coming soon</p>"},{"location":"examples/#light-scalar-mediator-single-phonons-solid-he","title":"Light Scalar Mediator, Single Phonons, Solid He","text":"<p>This will be run from a Jupyter notebook or as a python script</p> <pre><code>import numpy as np\n\nfrom darkmagic import Calculator, MaterialParameters, PhononMaterial, Numerics\nfrom darkmagic.benchmark_models import light_scalar_mediator\n\n# Masses in eV and times of day in hours (to calculate the earth's velocity)\nmasses = np.logspace(4, 10, 96)\ntimes = [0]\n\n# Phonons in Helium\nparams = MaterialParameters(N={\"e\": [2, 2], \"n\": [2, 2], \"p\": [2, 2]})\nmaterial = PhononMaterial(\"hcp_He\", params, \"tests/data/hcp_He_1GPa.phonopy.yaml\")\nmodel = light_scalar_mediator\n\n# Numerics\nnumerics = Numerics(\n    N_grid=[80, 40, 40],  # Spherical grid for momentum transfer\n    N_DWF_grid=[30, 30, 30],  # Monkhorst-Pack grid for Debye-Waller factor\n)\n\n# Create calculator object\nfull_calc = Calculator(\"scattering\", masses, material, model, numerics, times)\nfull_calc.evaluate()  # Run calculation\nfull_calc.to_file()  # Write HDF5 file (default name is \"material.name_model.name.h5\")\n</code></pre> <p>To run in parallel, simply run with <code>srun -n &lt;nprocs&gt; python script.py</code> or whatever alternative your system uses.</p>"},{"location":"formalism/","title":"Formalism","text":"<p>Coming soon! For now refer to this paper.</p>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>darkmagic<ul> <li>benchmark_models<ul> <li>anapole</li> <li>hadrophilic_scalar_mediator</li> <li>magnetic_dipole</li> <li>utils</li> </ul> </li> <li>calculator</li> <li>constants</li> <li>io</li> <li>material</li> <li>materials<ul> <li>VBTS_Magnon</li> <li>YIG_Magnon</li> </ul> </li> <li>model</li> <li>numerics</li> <li>parallel</li> <li>rate</li> <li>v_integrals</li> </ul> </li> </ul>"},{"location":"reference/darkmagic/","title":"darkmagic","text":""},{"location":"reference/darkmagic/calculator/","title":"calculator","text":""},{"location":"reference/darkmagic/calculator/#darkmagic.calculator.Calculator","title":"<code>Calculator(calc_type, m_chi, material, model, numerics, time=None, v_e=None)</code>","text":"<p>A class for calculating rates at a given list of masses and earth velocities.</p> <p>Parameters:</p> Name Type Description Default <code>calc_type</code> <code>str</code> <p>The type of calculation, only \"scattering\" is supported at the moment</p> required <code>m_chi</code> <code>ArrayLike</code> <p>The list of dark matter masses</p> required <code>material</code> <code>Material</code> <p>The material</p> required <code>model</code> <code>Model</code> <p>The model</p> required <code>numerics</code> <code>Numerics</code> <p>The numerical parameters</p> required <code>time</code> <code>ArrayLike</code> <p>The list of times in hours. Defaults to None.</p> <code>None</code> <code>v_e</code> <code>ArrayLike</code> <p>The list of earth velocities. Defaults to None (i.e., calculate from the tiems)</p> <code>None</code> <p>Raises:</p> Type Description <code>ValueError</code> <p>If neither time nor v_e are provided</p> <code>ValueError</code> <p>If both time and v_e are provided</p> Source code in <code>darkmagic/calculator.py</code> <pre><code>def __init__(\n    self,\n    calc_type: str,\n    m_chi: ArrayLike,\n    material: Material,\n    model: Model,\n    numerics: Numerics,\n    time: ArrayLike | None = None,\n    v_e: ArrayLike | None = None,\n):\n    \"\"\"\n    Initializes the calculator\n\n    Args:\n        calc_type (str): The type of calculation, only \"scattering\" is supported at the moment\n        m_chi (ArrayLike): The list of dark matter masses\n        material (Material): The material\n        model (Model): The model\n        numerics (Numerics): The numerical parameters\n        time (ArrayLike, optional): The list of times in hours. Defaults to None.\n        v_e (ArrayLike, optional): The list of earth velocities. Defaults to None (i.e., calculate from the tiems)\n\n    Raises:\n        ValueError: If neither time nor v_e are provided\n        ValueError: If both time and v_e are provided\n    \"\"\"\n    if calc_type not in [\"scattering\"]:\n        raise ValueError(\"Only 'scattering' is supported at the moment\")\n\n    if time is None and v_e is None:\n        raise ValueError(\"Either time or v_e must be provided\")\n    if time is not None and v_e is not None:\n        raise ValueError(\"Only one of time or v_e should be provided\")\n\n    self.v_e = self.compute_ve(time) if time is not None else v_e\n    self.time = time if time is not None else np.zeros(len(self.v_e))\n    self.numerics = numerics\n    self.material = material\n    self.m_chi = m_chi\n    self.model = model\n\n    # TODO: this is ugly\n    calc_class = RATE_CALC_CLASSES.get((calc_type, type(material)))\n    if calc_class is None:\n        warnings.warn(\n            \"Material class not recognized. This is possibly because you\"\n            \" are trying to read in a file that lacks material \"\n            \"information (e.g., PhonoDark formatted files). \"\n            \"If this is not the case, please report a bug.\"\n        )\n\n    self.calc_list = None\n    if calc_class is not None:\n        self.calc_list = [\n            [calc_class(m, v, material, model, numerics) for m in self.m_chi]\n            for v in self.v_e\n        ]\n\n    self._binned_rate, self._diff_rate, self._total_rate = None, None, None\n    self.binned_rate, self.diff_rate, self.total_rate = None, None, None\n</code></pre>"},{"location":"reference/darkmagic/calculator/#darkmagic.calculator.Calculator.from_file","title":"<code>from_file(filename, format='darkmagic')</code>  <code>classmethod</code>","text":"<p>Load a model from a file</p> Source code in <code>darkmagic/calculator.py</code> <pre><code>@classmethod\ndef from_file(cls, filename: str, format=\"darkmagic\"):\n    \"\"\"\n    Load a model from a file\n    \"\"\"\n    calc, numerics, model, data = read_h5(filename, format)\n    time = calc[\"time\"]\n    m_chi = calc[\"m_chi\"]\n    numerics = Numerics.from_dict(numerics)\n    model = Model.from_dict(model)\n    material = None  # TODO: add material info to DarkMAGIC output\n    if material is None:\n        warnings.warn(\n            \"Material information not found in file. Running the calculation won't work, but the parsed in results can be analyzed.\"\n        )\n\n    calc = cls(calc[\"calc_type\"], m_chi, material, model, numerics, time=time)\n    calc.binned_rate = data[\"binned_rate\"]\n    calc.diff_rate = data[\"diff_rate\"]\n    calc.total_rate = data[\"total_rate\"]\n\n    return calc\n</code></pre>"},{"location":"reference/darkmagic/calculator/#darkmagic.calculator.Calculator.evaluate","title":"<code>evaluate()</code>","text":"<p>Computes the differential rate for all masses and earth velocities</p> Source code in <code>darkmagic/calculator.py</code> <pre><code>def evaluate(self):\n    \"\"\"\n    Computes the differential rate for all masses and earth velocities\n    \"\"\"\n\n    n_ranks = COMM_WORLD.Get_size()  # Number of ranks\n    rank = COMM_WORLD.Get_rank()  # Processor rank\n\n    if rank == ROOT_PROCESS:\n        print(\"Done setting up MPI\")\n\n    all_tasks = None\n    if rank == ROOT_PROCESS:\n        all_tasks = distribute_load(n_ranks, self.m_chi, self.v_e)\n\n    task_list = COMM_WORLD.scatter(all_tasks, root=ROOT_PROCESS)\n\n    if rank == ROOT_PROCESS:\n        print(\"Done configuring calculation\")\n\n    diff_rates, binned_rates, total_rates = [], [], []\n    # Loop over the tasks and calculate the rates\n    for job in task_list:\n        if job[0] == JOB_SENTINEL and job[1] == JOB_SENTINEL:\n            continue\n        im, iv = job[0], job[1]\n        d, b, t = self.calc_list[iv][im].calculate_rate()\n        diff_rates.append([job, d.real])\n        binned_rates.append([job, b.real])\n        total_rates.append([job, t.real])\n\n    print(f\"Rank {rank} done calculating rates.\")\n\n    # TODO: this is hideous....\n    # Might be desirable to save these for parallel IO reimplementation\n    diff_rate = COMM_WORLD.gather(diff_rates, root=ROOT_PROCESS)\n    binned_rate = COMM_WORLD.gather(binned_rates, root=ROOT_PROCESS)\n    total_rate = COMM_WORLD.gather(total_rates, root=ROOT_PROCESS)\n\n    if rank == ROOT_PROCESS:\n        self._reshape_rates(diff_rate, binned_rate, total_rate)\n</code></pre>"},{"location":"reference/darkmagic/calculator/#darkmagic.calculator.Calculator.to_file","title":"<code>to_file(filename=None, format='darkmagic')</code>","text":"<p>Save the rates to a file.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The name of the file to save to. Defaults to None (i.e., use the default name, {material.name_model.name.h5}).</p> <code>None</code> <code>format</code> <code>str</code> <p>The format of the file. Defaults to \"darkmagic\".</p> <code>'darkmagic'</code> Source code in <code>darkmagic/calculator.py</code> <pre><code>def to_file(self, filename: str | None = None, format=\"darkmagic\"):\n    \"\"\"\n    Save the rates to a file.\n\n    Args:\n        filename (str, optional): The name of the file to save to. Defaults to None (i.e., use the default name, {material.name_model.name.h5}).\n        format (str, optional): The format of the file. Defaults to \"darkmagic\".\n    \"\"\"\n    if filename is None:\n        filename = f\"{self.material.name}_{self.model.shortname}.h5\"\n    # Make sure all the rates are note None\n    if (\n        self.diff_rate is None\n        or self.binned_rate is None\n        or self.total_rate is None\n    ) and COMM_WORLD.Get_rank() == ROOT_PROCESS:\n        raise ValueError(\n            \"Rates are not computed yet. Please run the calculation first using the evaluate method.\"\n        )\n\n    # TODO: re-implement parallel IO\n    write_h5(\n        filename,\n        self.material,\n        self.model,\n        self.numerics,\n        self.m_chi,\n        self.time,\n        self.v_e,\n        self.total_rate,\n        self.diff_rate,\n        self.binned_rate,\n        COMM_WORLD.Get_rank(),\n        None,\n        parallel=False,\n        format=format,\n    )\n</code></pre>"},{"location":"reference/darkmagic/calculator/#darkmagic.calculator.Calculator.compute_ve","title":"<code>compute_ve(times)</code>  <code>staticmethod</code>","text":"<p>Returns the earth's velocity in the lab frame at time t (in hours)</p> Source code in <code>darkmagic/calculator.py</code> <pre><code>@staticmethod\ndef compute_ve(times: float):\n    \"\"\"\n    Returns the earth's velocity in the lab frame at time t (in hours)\n    \"\"\"\n    theta = const.theta_earth\n\n    v_e = np.zeros((len(times), 3))\n    for it, t in enumerate(times):\n        phi = 2 * np.pi * (t / 24.0)\n        v_e[it] = const.VE * np.array(\n            [\n                np.sin(theta) * np.sin(phi),\n                np.cos(theta) * np.sin(theta) * (np.cos(phi) - 1),\n                (np.sin(theta) ** 2) * np.cos(phi) + np.cos(theta) ** 2,\n            ]\n        )\n    return v_e\n</code></pre>"},{"location":"reference/darkmagic/calculator/#darkmagic.calculator.Calculator.compute_reach","title":"<code>compute_reach(threshold_meV=1.0, exposure_kg_yr=1.0, n_cut=3.0, model=None, time=0)</code>","text":"<p>Computes the projected reach: the 95% C.L. constraint (3 events, no background) on \\(\bar{sigma}_n\\) or \\(\bar{sigma}_e\\) for a given model, in units of cm2 and normalizing to the appropriate reference cross section.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The path to the HDF5 file containing the data.</p> required <code>threshold_meV</code> <code>float</code> <p>The threshold in meV. Defaults to 1.0.</p> <code>1.0</code> <code>exposure_kg_yr</code> <code>float</code> <p>The exposure in kg.yr. Defaults to 1.0.</p> <code>1.0</code> <code>n_cut</code> <code>float</code> <p>The number of events. Defaults to 3.0.</p> <code>3.0</code> <code>model</code> <code>str</code> <p>The model to use. Defaults to None (i.e., finds the model name in the file)</p> <code>None</code> <code>time</code> <code>float | str</code> <p>The time to use. Defaults to 0.</p> <code>0</code> <p>Returns:</p> Type Description <code>array</code> <p>np.array: the cross section.</p> Source code in <code>darkmagic/calculator.py</code> <pre><code>def compute_reach(\n    self,\n    threshold_meV: float = 1.0,\n    exposure_kg_yr: float = 1.0,\n    n_cut: float = 3.0,\n    model: str | None = None,\n    time: float | str = 0,\n) -&gt; np.array:\n    \"\"\"\n    Computes the projected reach: the 95% C.L. constraint (3 events, no background) on $\\bar{sigma}_n$ or $\\bar{sigma}_e$ for a given model, in units of cm2 and normalizing to the appropriate reference cross section.\n\n    Args:\n        filename (str): The path to the HDF5 file containing the data.\n        threshold_meV (float, optional): The threshold in meV. Defaults to 1.0.\n        exposure_kg_yr (float, optional): The exposure in kg.yr. Defaults to 1.0.\n        n_cut (float, optional): The number of events. Defaults to 3.0.\n        model (str, optional): The model to use. Defaults to None (i.e., finds the model name in the file)\n        time (float | str, optional): The time to use. Defaults to 0.\n\n    Returns:\n        np.array: the cross section.\n    \"\"\"\n\n    energy_bin_width = self.numerics.bin_width\n    threshold = self.numerics._threshold  # legacy for PD support\n    m_chi = self.m_chi\n    # get time index\n    try:\n        t_idx = np.argwhere(self.time == time)[0][0]\n    except IndexError as e:\n        raise ValueError(f\"Time {time} not found in the list of times.\") from e\n\n    raw_binned_rate = 1e-100 + self.diff_rate[t_idx]  # TODO: bad names...\n\n    # Vanilla PhonoDark calcs have a threshold of 1 meV by default\n    # We need to account for that in the binning\n    bin_cutoff = int(threshold_meV * 1e-3 / energy_bin_width) - int(\n        threshold / energy_bin_width\n    )\n\n    model_name = model if model is not None else self.model.shortname\n    if model_name is None:\n        raise ValueError(\n            \"Model not provided and not found in the file. \"\n            \"Please provide the model name.\"\n        )\n    sigma = n_cut / np.sum(raw_binned_rate[:, bin_cutoff:], axis=1)\n    sigma /= (\n        exposure_kg_yr\n        * const.kg_yr\n        * const.cm2\n        * BUILT_IN_MODELS[model_name].ref_cross_sect(m_chi)\n    )\n\n    return sigma\n</code></pre>"},{"location":"reference/darkmagic/constants/","title":"constants","text":"<p>Constants in natural units (unless otherwise specified).</p>"},{"location":"reference/darkmagic/io/","title":"io","text":""},{"location":"reference/darkmagic/io/#darkmagic.io.read_h5","title":"<code>read_h5(filename, format)</code>","text":"<p>Reads data from an HDF5 file based on the specified format.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The path to the HDF5 file to read.</p> required <code>format</code> <code>str</code> <p>The format of the data to read. Should be either \"phonodark\" or \"darkmagic\".</p> required <p>Returns:</p> Type Description <p>The data read from the HDF5 file based on the specified format.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the provided format is not recognized.</p> Source code in <code>darkmagic/io.py</code> <pre><code>def read_h5(filename, format):\n    \"\"\"\n    Reads data from an HDF5 file based on the specified format.\n\n    Args:\n        filename (str): The path to the HDF5 file to read.\n        format (str): The format of the data to read. Should be either \"phonodark\" or \"darkmagic\".\n\n    Returns:\n        The data read from the HDF5 file based on the specified format.\n\n    Raises:\n        ValueError: If the provided format is not recognized.\n    \"\"\"\n\n    if format == \"phonodark\":\n        return read_phonodark(filename)\n    elif format == \"darkmagic\":\n        return read_darkmagic(filename)\n    else:\n        raise ValueError(f\"Format {format} not recognized.\")\n</code></pre>"},{"location":"reference/darkmagic/io/#darkmagic.io.read_darkmagic","title":"<code>read_darkmagic(filename)</code>","text":"<p>Reads data from an HDF5 file in the 'darkmagic' format.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The path to the HDF5 file in DarkMAGIC format.</p> required <p>Returns:</p> Type Description <code>Tuple[dict, dict, dict, dict]</code> <p>Tuple containing the calculated values, numerics, model, and data in 'darkmagic' format.</p> Source code in <code>darkmagic/io.py</code> <pre><code>def read_darkmagic(filename: str) -&gt; Tuple[dict, dict, dict, dict]:\n    \"\"\"\n    Reads data from an HDF5 file in the 'darkmagic' format.\n\n    Args:\n        filename (str): The path to the HDF5 file in DarkMAGIC format.\n\n    Returns:\n        Tuple containing the calculated values, numerics, model, and data in 'darkmagic' format.\n    \"\"\"\n    with h5py.File(filename, \"r\") as f:\n        calc = dict_from_h5group(f[\"calc\"])\n        numerics = dict_from_h5group(f[\"numerics\"])\n        model = dict_from_h5group(f[\"model\"])\n        data = dict_from_h5group(f[\"data\"])\n    return calc, numerics, model, data\n</code></pre>"},{"location":"reference/darkmagic/io/#darkmagic.io.read_phonodark","title":"<code>read_phonodark(filename)</code>","text":"<p>Reads data from an HDF5 file in the 'phonodark' format and converts it to the 'darkmagic' format.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The path to the HDF5 file in 'phonodark' format.</p> required <p>Returns:</p> Type Description <code>Tuple[dict, dict, dict, dict]</code> <p>Tuple containing the calculated values, numerics, model, and data converted to 'DarkMAGIC' format.</p> Source code in <code>darkmagic/io.py</code> <pre><code>def read_phonodark(filename: str) -&gt; Tuple[dict, dict, dict, dict]:\n    \"\"\"\n    Reads data from an HDF5 file in the 'phonodark' format and converts it to the 'darkmagic' format.\n\n    Args:\n        filename (str): The path to the HDF5 file in 'phonodark' format.\n\n    Returns:\n        Tuple containing the calculated values, numerics, model, and data converted to 'DarkMAGIC' format.\n    \"\"\"\n\n    def get_phonodark_rate(group):\n        return np.array(\n            [\n                [data[group][str(t)][str(m)] for m in range(len(masses))]\n                for t in range(len(times))\n            ]\n        )\n\n    with h5py.File(filename, \"r\") as f:\n        particle_physics = dict_from_h5group(f[\"particle_physics\"])\n        numerics = dict_from_h5group(f[\"numerics\"])\n        data = dict_from_h5group(f[\"data\"])\n        times = particle_physics[\"times\"]\n        masses = particle_physics[\"dm_properties\"][\"mass_list\"]\n\n        data = {\n            \"diff_rate\": get_phonodark_rate(\"diff_rate\"),\n            \"binned_rate\": get_phonodark_rate(\"binned_rate\"),\n            \"total_rate\": get_phonodark_rate(\"rate\")[0].T,\n        }\n\n        calc, numerics, model = phonodark_to_darkmagic(\n            numerics, particle_physics, times, masses\n        )\n\n    return calc, numerics, model, data\n</code></pre>"},{"location":"reference/darkmagic/io/#darkmagic.io.write_darkmagic","title":"<code>write_darkmagic(out_file, material, model, numerics, m_chi, time, v_e, total_rate, diff_rate, binned_rate, comm=None)</code>","text":"<p>Write data to hdf5 file in DarkMAGIC format.</p> <p>Parameters:</p> Name Type Description Default <code>out_file</code> <p>Path to the output HDF5 file.</p> required <code>material</code> <p>Material object.</p> required <code>model</code> <p>Model object.</p> required <code>numerics</code> <p>Numerics object.</p> required <code>m_chi</code> <p>List of masses for the jobs.</p> required <code>time</code> <p>List of times for the jobs.</p> required <code>all_total_rate_list</code> <p>List of total rate data.</p> required <code>all_diff_rate_list</code> <p>List of differential rate data.</p> required <code>all_binned_rate_list</code> <p>List of binned rate data.</p> required <code>comm</code> <p>MPI communicator for parallel writing (default is None).</p> <code>None</code> <p>Returns:</p> Type Description <p>None</p> Source code in <code>darkmagic/io.py</code> <pre><code>def write_darkmagic(\n    out_file,\n    material,\n    model,\n    numerics,\n    m_chi,\n    time,\n    v_e,\n    total_rate,\n    diff_rate,\n    binned_rate,\n    comm=None,\n):\n    \"\"\"\n    Write data to hdf5 file in DarkMAGIC format.\n\n    Args:\n        out_file: Path to the output HDF5 file.\n        material: Material object.\n        model: Model object.\n        numerics: Numerics object.\n        m_chi: List of masses for the jobs.\n        time: List of times for the jobs.\n        all_total_rate_list: List of total rate data.\n        all_diff_rate_list: List of differential rate data.\n        all_binned_rate_list: List of binned rate data.\n        comm: MPI communicator for parallel writing (default is None).\n\n    Returns:\n        None\n    \"\"\"\n\n    # Get appropriate context manager for serial/parallel\n    if comm is None:\n        cm = h5py.File(out_file, \"w\")\n    else:\n        cm = h5py.File(out_file, \"w\", driver=\"mpio\", comm=comm)\n\n    with cm as out_f:\n        h5group_to_dict(out_f, \"numerics\", numerics.to_dict())\n        h5group_to_dict(out_f, \"model\", model.to_dict(serializable=True))\n        calc = {\n            \"calc_type\": \"scattering\",\n            \"m_chi\": m_chi,\n            \"time\": time,\n            \"v_e\": v_e,\n        }\n        # Create groups/datasets and write out input parameters\n        h5group_to_dict(out_f, \"calc\", calc)\n        out_f.create_dataset(\"version\", data=np.array([VERSION], dtype=\"S\"))\n\n        nt, nm = len(time), len(m_chi)\n        num_bins = diff_rate.shape[-1]\n        num_modes = binned_rate.shape[-1]\n\n        out_f.create_dataset(\"data/diff_rate\", shape=(nt, nm, num_bins), dtype=\"f8\")\n        out_f.create_dataset(\"data/binned_rate\", shape=(nt, nm, num_modes), dtype=\"f8\")\n        out_f.create_dataset(\"data/total_rate\", shape=(nt, nm), dtype=\"f8\")\n\n        out_f[\"data\"][\"diff_rate\"][...] = diff_rate\n        out_f[\"data\"][\"binned_rate\"][...] = binned_rate\n        out_f[\"data\"][\"total_rate\"][...] = total_rate\n</code></pre>"},{"location":"reference/darkmagic/io/#darkmagic.io.write_phonodark","title":"<code>write_phonodark(out_file, material, model, numerics, masses, times, v_e, all_total_rate_list, all_diff_rate_list, all_binned_rate_list, comm=None)</code>","text":"<p>Write data to hdf5 file in PhonoDark format</p> <p>all_*_rate_list has a complicated format. For starters, it has as many elements as there are jobs. Each element is a list of the (m_chi, time) pairs that have been computed. Each of those elements is a two element array. The first element is a tuple of the mass and time index. The second element is either a scalar (total) or an array (binned and diff). For binned and diff, the dimensions of the array are num_bins and num_modes respectively.</p> <p>So for example, if we have 4 masses and 2 times, distributed over 4 jobs, then diff_rate list will look like this: [     # This is the job 1 array, which does mass index 0 at time indices 0,1     [ [ [0, 0], [num_bins elements]], [[0, 1], [num_bins_elements], ...], # job 1     # This is the job 1 array, which does mass index 1 at time indices 0,1     [ [ [1, 0], [num_bins elements]], [[1, 1], [num_bins_elements], ...], # job 2     ... ] This format is temporary, just for backwards compatibility with PhonoDark.</p> <p>Parameters:</p> Name Type Description Default <code>out_file</code> <p>Path to the output HDF5 file.</p> required <code>material</code> <p>Material object.</p> required <code>model</code> <p>Model object.</p> required <code>numerics</code> <p>Numerics object.</p> required <code>masses</code> <p>List of masses for the jobs.</p> required <code>times</code> <p>List of times for the jobs.</p> required <code>all_total_rate_list</code> <p>List of total rate data.</p> required <code>all_diff_rate_list</code> <p>List of differential rate data.</p> required <code>all_binned_rate_list</code> <p>List of binned rate data.</p> required <code>comm</code> <p>MPI communicator for parallel writing (default is None).</p> <code>None</code> <p>Returns:</p> Type Description <p>None</p> Source code in <code>darkmagic/io.py</code> <pre><code>def write_phonodark(\n    out_file,\n    material,\n    model,\n    numerics,\n    masses,\n    times,\n    v_e,\n    all_total_rate_list,\n    all_diff_rate_list,\n    all_binned_rate_list,\n    comm=None,\n):\n    \"\"\"\n\n    Write data to hdf5 file in PhonoDark format\n\n    all_*_rate_list has a complicated format.\n    For starters, it has as many elements as there are jobs. Each element is a list of the\n    (m_chi, time) pairs that have been computed. Each of those elements is a two element array.\n    The first element is a tuple of the mass and time index. The second element is either a scalar\n    (total) or an array (binned and diff). For binned and diff, the dimensions of the array are\n    num_bins and num_modes respectively.\n\n    So for example, if we have 4 masses and 2 times, distributed over 4 jobs, then diff_rate list will look like this:\n    [\n        # This is the job 1 array, which does mass index 0 at time indices 0,1\n        [ [ [0, 0], [num_bins elements]], [[0, 1], [num_bins_elements], ...], # job 1\n        # This is the job 1 array, which does mass index 1 at time indices 0,1\n        [ [ [1, 0], [num_bins elements]], [[1, 1], [num_bins_elements], ...], # job 2\n        ...\n    ]\n    This format is temporary, just for backwards compatibility with PhonoDark.\n\n    Args:\n      out_file: Path to the output HDF5 file.\n      material: Material object.\n      model: Model object.\n      numerics: Numerics object.\n      masses: List of masses for the jobs.\n      times: List of times for the jobs.\n      all_total_rate_list: List of total rate data.\n      all_diff_rate_list: List of differential rate data.\n      all_binned_rate_list: List of binned rate data.\n      comm: MPI communicator for parallel writing (default is None).\n\n    Returns:\n      None\n    \"\"\"\n\n    def get_dicts(model, numerics, masses, times):\n        physics_parameters = {\n            \"threshold\": numerics._threshold,\n            \"times\": times,\n            \"Fmed_power\": model.Fmed_power,\n            \"power_V\": model.power_V,\n            \"special_model\": False,\n            \"model_name\": \"mdm\",\n        }\n        dm_properties_dict = {\n            \"spin\": model.S_chi,\n            \"mass_list\": masses,\n        }\n        coeff = model.coeff_prefactor\n        numerics_parameters = {\n            \"n_a\": numerics.N_grid[0],\n            \"n_b\": numerics.N_grid[1],\n            \"n_c\": numerics.N_grid[2],\n            \"power_a\": numerics._power_abc[0],\n            \"power_b\": numerics._power_abc[1],\n            \"power_c\": numerics._power_abc[2],\n            \"n_DW_x\": numerics.N_DWF_grid[0],\n            \"n_DW_y\": numerics.N_DWF_grid[1],\n            \"n_DW_z\": numerics.N_DWF_grid[2],\n            \"energy_bin_width\": numerics.bin_width,\n            \"q_cut\": numerics.use_q_cut,\n            \"special_mesh\": numerics._use_special_mesh,\n        }\n        return physics_parameters, dm_properties_dict, coeff, numerics_parameters\n\n    physics_parameters, dm_properties_dict, c_dict, numerics_parameters = get_dicts(\n        model, numerics, masses, times\n    )\n\n    # Get appropriate context manager for serial/parallel\n    cm = _get_context_manager(out_file, comm)\n\n    with cm as h5f:\n        # Create groups/datasets and write out input parameters\n        h5group_to_dict(h5f, \"numerics\", numerics_parameters)\n        h5group_to_dict(h5f, \"particle_physics\", physics_parameters)\n        h5f.create_dataset(\"version\", data=np.array([\"0.0.1\"], dtype=\"S\"))\n        h5group_to_dict(h5f, \"particle_physics/dm_properties\", dm_properties_dict)\n        h5group_to_dict(h5f, \"particle_physics/c_coeffs\", c_dict)\n\n        if isinstance(all_diff_rate_list, list):\n            # Old implementation friendly\n            num_bins = len(all_diff_rate_list[0][0][1])\n            num_modes = len(all_binned_rate_list[0][0][1])\n        else:\n            num_bins = all_diff_rate_list.shape[-1]\n            num_modes = all_binned_rate_list.shape[-1]\n\n        # In parallel all datasets need to be created by all ranks\n        for i in range(len(physics_parameters[\"times\"])):\n            for j in range(len(dm_properties_dict[\"mass_list\"])):\n                h5f.create_dataset(f\"data/rate/{i}/{j}\", shape=(1,), dtype=\"f8\")\n                h5f.create_dataset(\n                    f\"data/diff_rate/{i}/{j}\", shape=(num_bins,), dtype=\"f8\"\n                )\n                h5f.create_dataset(\n                    f\"data/binned_rate/{i}/{j}\", shape=(num_modes,), dtype=\"f8\"\n                )\n                # This will work for the new implementation where\n                # the data is arrays indexed as (time, mass), but not\n                # in parallel. See parallel implementation below.\n                h5f[f\"data/rate/{i}/{j}\"][...] = all_total_rate_list[i, j]\n                h5f[f\"data/diff_rate/{i}/{j}\"][...] = all_diff_rate_list[i, j]\n                h5f[f\"data/binned_rate/{i}/{j}\"][...] = all_binned_rate_list[i, j]\n</code></pre>"},{"location":"reference/darkmagic/io/#darkmagic.io.dict_from_h5group","title":"<code>dict_from_h5group(group)</code>","text":"<p>Recurses through an h5py group and creates a dictionary with the same structure.</p> Source code in <code>darkmagic/io.py</code> <pre><code>def dict_from_h5group(group: h5py.Group):\n    \"\"\"\n    Recurses through an h5py group and creates a dictionary with the same structure.\n    \"\"\"\n    result = {}\n    for k in group.keys():\n        v = group[k]\n        result[k] = dict_from_h5group(v) if isinstance(v, h5py.Group) else np.array(v)\n        if isinstance(result[k], np.ndarray) and result[k].ndim == 0:\n            result[k] = result[k].item()\n        # Convert string arrays to strings\n        if isinstance(result[k], np.ndarray) and result[k].dtype.char == \"S\":\n            result[k] = result[k].astype(str)[0]\n    return result\n</code></pre>"},{"location":"reference/darkmagic/io/#darkmagic.io.h5group_to_dict","title":"<code>h5group_to_dict(hdf5_file, group_name, data_dict)</code>","text":"<p>Recurses through a dictionary and creates appropriate groups or datasets This is parallel friendly, nothing is variable length.</p> <p>Parameters:</p> Name Type Description Default <code>hdf5_file</code> <code>File</code> <p>The h5py file object to write to</p> required <code>group_name</code> <code>str</code> <p>The name of the group to write to</p> required <code>data_dict</code> <code>dict</code> <p>The dictionary to write</p> required <p>Returns:</p> Type Description <p>None</p> Source code in <code>darkmagic/io.py</code> <pre><code>def h5group_to_dict(hdf5_file: h5py.File, group_name: str, data_dict: dict):\n    \"\"\"\n    Recurses through a dictionary and creates appropriate groups or datasets\n    This is parallel friendly, nothing is variable length.\n\n    Args:\n        hdf5_file: The h5py file object to write to\n        group_name: The name of the group to write to\n        data_dict: The dictionary to write\n\n    Returns:\n        None\n    \"\"\"\n\n    for index in data_dict:\n        if isinstance(data_dict[index], dict):\n            h5group_to_dict(hdf5_file, f\"{group_name}/{index}\", data_dict[index])\n        else:\n            data = (\n                np.array([data_dict[index]], dtype=\"S\")\n                if isinstance(data_dict[index], str)\n                else data_dict[index]\n            )\n            hdf5_file.create_dataset(f\"{group_name}/{index}\", data=data)\n</code></pre>"},{"location":"reference/darkmagic/io/#darkmagic.io.phonodark_to_darkmagic","title":"<code>phonodark_to_darkmagic(n, pp, times, m_chi)</code>","text":"<p>Convert the dictionaries from PhonoDark to DarkMAGIC</p> <p>Parameters:</p> Name Type Description Default <code>n</code> <code>dict</code> <p>Numerics dictionary from PhonoDark</p> required <code>pp</code> <code>dict</code> <p>Particle physics dictionary from PhonoDark</p> required <code>times</code> <code>ndarray</code> <p>Array of times</p> required <code>m_chi</code> <code>ndarray</code> <p>Array of dark matter masses</p> required <p>Returns:</p> Type Description <code>Tuple[dict, dict, dict]</code> <p>Tuple of Calculator, Numerics, Model dictionaries</p> Source code in <code>darkmagic/io.py</code> <pre><code>def phonodark_to_darkmagic(\n    n: dict, pp: dict, times: np.ndarray, m_chi: np.ndarray\n) -&gt; Tuple[dict, dict, dict]:\n    \"\"\"\n    Convert the dictionaries from PhonoDark to DarkMAGIC\n\n    Args:\n        n (dict): Numerics dictionary from PhonoDark\n        pp (dict): Particle physics dictionary from PhonoDark\n        times (np.ndarray): Array of times\n        m_chi (np.ndarray): Array of dark matter masses\n\n    Returns:\n        Tuple of Calculator, Numerics, Model dictionaries\n    \"\"\"\n    numerics = {\n        \"_threshold\": pp[\"threshold\"],\n        \"N_grid\": [n[\"n_a\"], n[\"n_b\"], n[\"n_c\"]],\n        \"_power_abc\": [n[\"power_a\"], n[\"power_b\"], n[\"power_c\"]],\n        \"N_DWF_grid\": [n[\"n_DW_x\"], n[\"n_DW_y\"], n[\"n_DW_z\"]],\n        \"use_q_cut\": n[\"q_cut\"],\n        \"_use_special_mesh\": n[\"special_mesh\"],\n        \"bin_width\": n[\"energy_bin_width\"],\n    }\n    warnings.warn(\n        \"You are reconstructing a Calculator object from a \"\n        \"PhonoDark formatted HDF5 file. These files do not \"\n        \"contain the coefficient functions, so they will be set to \"\n        \"one, which is likely incorrect. Use caution if rerunning \"\n        \"this calculation.\"\n    )\n    coeff_func = {\n        alpha: {psi: one for psi, f in c.items()} for alpha, c in pp[\"c_coeffs\"].items()\n    }\n\n    def F_med_prop(grid):\n        return grid.q_norm ** (-pp[\"Fmed_power\"])\n\n    model = {\n        \"shortname\": pp.get(\"model_name\"),\n        \"S_chi\": pp[\"dm_properties\"][\"spin\"],\n        \"coeff_prefactor\": pp[\"c_coeffs\"],\n        \"coeff_func\": coeff_func,\n        \"F_med_prop\": F_med_prop,\n        \"name\": \"Unknown Model\",\n    }\n    calc = {\n        \"calc_type\": \"scattering\",\n        \"m_chi\": m_chi,\n        \"time\": times,\n        \"v_e\": None,\n    }\n    return calc, numerics, model\n</code></pre>"},{"location":"reference/darkmagic/material/","title":"material","text":""},{"location":"reference/darkmagic/material/#darkmagic.material.MaterialParameters","title":"<code>MaterialParameters(N=None, S=None, L=None, L_dot_S=None, L_tens_S=None, lambda_S=None, lambda_L=None, m_psi=None)</code>","text":"<p>Class for DM-relevant material properties, such as the number of fermions, spin, orbital angular momentum, etc.</p> <p>Attributes:</p> Name Type Description <code>N</code> <code>dict</code> <p>Fermion numbers.</p> <code>S</code> <code>dict</code> <p>Spin vectors.</p> <code>L</code> <code>dict</code> <p>Orbital angular momentum vectors.</p> <code>L_dot_S</code> <code>dict</code> <p>\\(L \\cdot S\\)</p> <code>L_tens_S</code> <code>dict</code> <p>Spin orbit coupling tensor \\(L \\otimes S\\)</p> <code>lambda_S</code> <code>ArrayLike</code> <p>spin-coefficient for magnons</p> <code>lambda_L</code> <code>ArrayLike</code> <p>orbital angular mom.-coefficient for magnons</p> <code>m_psi</code> <code>dict</code> <p>Dictionary of masses for different particles.</p> <p>Methods:</p> Name Description <code>validate_for_phonons</code> <p>Validates that the material properties are suitable for phonon calculations.</p> <code>validate_for_magnons</code> <p>Validates that the material properties are suitable for magnon calculations.</p> <p>Parameters:</p> Name Type Description Default <code>N</code> <code>dict</code> <p>Fermion numbers.</p> <code>None</code> <code>S</code> <code>dict</code> <p>Spin vectors.</p> <code>None</code> <code>L</code> <code>dict</code> <p>Orbital angular momentum vectors.</p> <code>None</code> <code>L_dot_S</code> <code>dict</code> <p>\\(L \\cdot S\\)</p> <code>None</code> <code>L_tens_S</code> <code>dict</code> <p>Spin orbit coupling tensor \\(L \\otimes S\\)</p> <code>None</code> <code>lambda_S</code> <code>ArrayLike</code> <p>spin-coefficient for magnons</p> <code>None</code> <code>lambda_L</code> <code>ArrayLike</code> <p>orbital angular mom.-coefficient for magnons</p> <code>None</code> <code>m_psi</code> <code>dict</code> <p>Masses of the fermions. Defaults to NIST values.</p> <code>None</code> Source code in <code>darkmagic/material.py</code> <pre><code>def __init__(\n    self,\n    N: dict = None,\n    S: dict = None,\n    L: dict = None,\n    L_dot_S: dict = None,\n    L_tens_S: dict = None,\n    lambda_S: ArrayLike = None,\n    lambda_L: ArrayLike = None,\n    m_psi: dict = None,\n):\n    r\"\"\"\n    Material properties constructor. All dicts have keys \"n\", \"p\", \"e\" for neutron, proton and electron. Any missing values are instantiated to 0.\n\n    Args:\n        N (dict, optional): Fermion numbers.\n        S (dict, optional): Spin vectors.\n        L (dict, optional): Orbital angular momentum vectors.\n        L_dot_S (dict, optional): $L \\cdot S$\n        L_tens_S (dict, optional): Spin orbit coupling tensor $L \\otimes S$\n        lambda_S (ArrayLike, optional): spin-coefficient for magnons\n        lambda_L (ArrayLike, optional): orbital angular mom.-coefficient for magnons\n        m_psi (dict, optional): Masses of the fermions. Defaults to NIST values.\n    \"\"\"\n    # Phonons\n    self.N = N\n    self.S = S\n    self.L = L\n    self.L_dot_S = L_dot_S\n    self.L_tens_S = L_tens_S\n    # Magnons\n    self.lambda_S = lambda_S\n    self.lambda_L = lambda_L\n    # Mass of the particles\n    self.m_psi = m_psi\n</code></pre>"},{"location":"reference/darkmagic/material/#darkmagic.material.MaterialParameters.validate_for_phonons","title":"<code>validate_for_phonons(n_atoms)</code>","text":"<p>Validates that the material properties are suitable for phonons. Namely, at least one of N, S, L, L_dot_S or L_tens_S must be defined.</p> <p>Parameters:</p> Name Type Description Default <code>n_atoms</code> <code>int</code> <p>Number of atoms in the material.</p> required <p>Raises:</p> Type Description <code>AssertionError</code> <p>If any of the required material properties for phonons are missing or have incorrect dimensions.</p> Source code in <code>darkmagic/material.py</code> <pre><code>def validate_for_phonons(self, n_atoms: int) -&gt; None:\n    \"\"\"\n    Validates that the material properties are suitable for phonons.\n    Namely, at least one of N, S, L, L_dot_S or L_tens_S must be defined.\n\n    Args:\n        n_atoms (int): Number of atoms in the material.\n\n    Raises:\n        AssertionError: If any of the required material properties for phonons are missing or have incorrect dimensions.\n\n    \"\"\"\n    assert any([self.N, self.S, self.L, self.L_dot_S, self.L_tens_S])\n    for d in [self.N, self.S, self.L, self.L_dot_S, self.L_tens_S]:\n        if d:\n            assert any(np.any(v) for v in d.values())\n\n    self._validate_input(n_atoms)\n</code></pre>"},{"location":"reference/darkmagic/material/#darkmagic.material.MaterialParameters.validate_for_magnons","title":"<code>validate_for_magnons(n_atoms)</code>","text":"<p>Validates that the material properties are suitable for magnons. Namely, at least one of lambda_S and lambda_L must be defined.</p> <p>Parameters:</p> Name Type Description Default <code>n_atoms</code> <code>int</code> <p>Number of atoms in the material.</p> required <p>Raises:</p> Type Description <code>AssertionError</code> <p>If any of the required material properties for magnons are missing or have incorrect dimensions.</p> Source code in <code>darkmagic/material.py</code> <pre><code>def validate_for_magnons(self, n_atoms: int) -&gt; None:\n    \"\"\"\n    Validates that the material properties are suitable for magnons. Namely, at least one of lambda_S and lambda_L must be defined.\n\n    Args:\n        n_atoms (int): Number of atoms in the material.\n\n    Raises:\n        AssertionError: If any of the required material properties for magnons are missing or have incorrect dimensions.\n\n    \"\"\"\n    assert any([np.any(self.lambda_S), np.any(self.lambda_L)])\n    # TODO: not nice to have so many return values\n    self._validate_input(n_atoms)\n</code></pre>"},{"location":"reference/darkmagic/material/#darkmagic.material.Material","title":"<code>Material(name, properties, structure, m_atoms)</code>","text":"<p>             Bases: <code>ABC</code></p> <p>Represents a generic material with its structural and atomic properties.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>The name of the material.</p> <code>properties</code> <code>MaterialProperties</code> <p>The properties of the material.</p> <code>real_frac_to_cart</code> <code>ndarray</code> <p>The transformation matrix from fractional to Cartesian coordinates (units 1/eV), in real space.</p> <code>real_cart_to_frac</code> <code>ndarray</code> <p>The transformation matrix from Cartesian (units 1/eV) to fractional coordinates, in real space.</p> <code>recip_frac_to_cart</code> <code>ndarray</code> <p>The transformation matrix from fractional to Cartesian coordinates (units eV), in k-space.</p> <code>recip_cart_to_frac</code> <code>ndarray</code> <p>The transformation matrix from Cartesian (units eV) to fractional coordinates, in k-space.</p> <code>m_atoms</code> <code>ArrayLike</code> <p>an array of atomic masses, in eV.</p> <code>m_cell</code> <code>ndarray</code> <p>The total mass of the atoms in the material, in eV.</p> <code>xj</code> <code>ndarray</code> <p>The Cartesian coordinates (units 1/eV) of the atoms in the material.</p> <code>structure</code> <code>Structure</code> <p>the crystal structure <code>pymatgen</code> <code>Structure</code> object.</p> <code>n_atoms</code> <code>int</code> <p>The number of atoms in the material.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the material.</p> required <code>properties</code> <code>MaterialProperties</code> <p>The properties of the material.</p> required <code>structure</code> <code>Structure</code> <p>The structure of the material.</p> required <code>m_atoms</code> <code>ArrayLike</code> <p>atomic masses in eV.</p> required Source code in <code>darkmagic/material.py</code> <pre><code>def __init__(\n    self,\n    name: str,\n    properties: MaterialParameters,\n    structure: Structure,\n    m_atoms: ArrayLike,\n):\n    \"\"\"\n    Constructor for a generic Material object\n\n    Args:\n        name (str): The name of the material.\n        properties (MaterialProperties): The properties of the material.\n        structure (Structure): The structure of the material.\n        m_atoms (ArrayLike): atomic masses in eV.\n    \"\"\"\n    # Material properties\n    self.name = name\n    self.properties = properties\n\n    # Define transformation matrices\n    self.real_frac_to_cart = structure.lattice.matrix.T\n    self.real_cart_to_frac = LA.inv(self.real_frac_to_cart)\n    self.recip_frac_to_cart = structure.lattice.reciprocal_lattice.matrix.T\n    self.recip_cart_to_frac = LA.inv(self.recip_frac_to_cart)\n\n    # Atomic and structural properties\n    self.m_atoms = m_atoms\n    self.m_cell = np.sum(m_atoms)\n    self.xj = structure.cart_coords\n    self.structure = structure\n    self.n_atoms = len(structure.species)\n\n    # Internal variables\n    self._max_dE = None\n    self._q_cut = None\n</code></pre>"},{"location":"reference/darkmagic/material/#darkmagic.material.Material.max_dE","title":"<code>max_dE: float</code>  <code>abstractmethod</code> <code>property</code>","text":"<p>Abstract method for estimating the maximum energy deposition</p>"},{"location":"reference/darkmagic/material/#darkmagic.material.Material.q_cut","title":"<code>q_cut: float</code>  <code>property</code>","text":"<p>Abstract method for estimating a cutoff for the momentum transfer</p>"},{"location":"reference/darkmagic/material/#darkmagic.material.Material.get_eig","title":"<code>get_eig(grid, with_eigenvectors=True)</code>  <code>abstractmethod</code>","text":"<p>Abstract method for computing eigenvalues and eigenvectors</p> Source code in <code>darkmagic/material.py</code> <pre><code>@abstractmethod\ndef get_eig(\n    self, grid: SphericalGrid | MonkhorstPackGrid, with_eigenvectors: bool = True\n) -&gt; Tuple[np.ndarray, np.ndarray]:\n    \"\"\"\n    Abstract method for computing eigenvalues and eigenvectors\n    \"\"\"\n    pass\n</code></pre>"},{"location":"reference/darkmagic/material/#darkmagic.material.PhononMaterial","title":"<code>PhononMaterial(name, properties, phonopy_yaml_path)</code>","text":"<p>             Bases: <code>Material</code></p> <p>A class for materials with phonons.</p> <p>Attributes:</p> Name Type Description <code>phonopy_file</code> <code>Phonopy</code> <p>The Phonopy object for the material's phonons</p> <code>n_modes</code> <code>int</code> <p>The number of phonon modes in the material.</p> <code>born</code> <code>ndarray</code> <p>The born effective charges</p> <code>epsilon</code> <code>ndarray</code> <p>The dielectric tensor</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the material.</p> required <code>properties</code> <code>MaterialProperties</code> <p>The properties of the material.</p> required <code>phonopy_yaml_path</code> <code>str</code> <p>The path to the Phonopy YAML file.</p> required Source code in <code>darkmagic/material.py</code> <pre><code>def __init__(\n    self, name: str, properties: MaterialParameters, phonopy_yaml_path: str\n):\n    \"\"\"\n    Constructor for PhononMaterial objects.\n\n    Args:\n        name (str): The name of the material.\n        properties (MaterialProperties): The properties of the material.\n        phonopy_yaml_path (str): The path to the Phonopy YAML file.\n\n    \"\"\"\n    # TODO: Need a check for when phonopy_yaml does not have NAC\n    phonopy_file = phonopy.load(phonopy_yaml=phonopy_yaml_path, is_nac=True)\n    # TODO: should be a dict that has the correct factor for all codes\n    length_factor = const.bohr_to_Ang if phonopy_file.calculator == \"qe\" else 1.0\n    self.phonopy_file = phonopy_file\n    n_atoms = phonopy_file.primitive.get_number_of_atoms()\n    self.n_modes = 3 * n_atoms\n\n    properties.validate_for_phonons(n_atoms)\n\n    m_atoms = phonopy_file.primitive.masses * const.amu_to_eV\n\n    # NAC parameters (born effective charges and dielectric tensor)\n    self.born = np.array(\n        phonopy_file.nac_params.get(\"born\", np.zeros((n_atoms, 3, 3)))\n    )\n    self.epsilon = np.array(\n        phonopy_file.nac_params.get(\"dielectric\", np.identity(3))\n    )\n\n    # Create a Structure object\n    # At some point should make careful assessment of primitive vs unit_cell\n    # PhonoDark uses primitive, but what about when it's different from unit_cell?\n    positions = phonopy_file.primitive.scaled_positions\n    lattice = (\n        np.array(phonopy_file.primitive.cell) * const.Ang_to_inveV * length_factor\n    )\n    species = phonopy_file.primitive.symbols\n\n    structure = Structure(lattice, species, positions)\n\n    super().__init__(name, properties, structure, m_atoms)\n</code></pre>"},{"location":"reference/darkmagic/material/#darkmagic.material.PhononMaterial.max_dE","title":"<code>max_dE: float</code>  <code>property</code>","text":"<p>Returns omega_ph_max = max(omega_ph) if there are optical modes, otherwise returns the average over the entire Brillouin zone. The quantities are obviously not the same but should be the same order. See theoretical framework paper, paragraph in middle of page 24 (of published version).</p> <p>TODO: clarify this</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>the maximum energy deposition</p>"},{"location":"reference/darkmagic/material/#darkmagic.material.PhononMaterial.q_cut","title":"<code>q_cut: float</code>  <code>property</code>","text":"<p>The Debye-Waller factor suppresses the rate at larger q beyond q ~ np.sqrt(m_atom * omega_ph). This method calculates an estimate for the cutoff value of q.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The cutoff value of q.</p>"},{"location":"reference/darkmagic/material/#darkmagic.material.PhononMaterial.get_eig","title":"<code>get_eig(grid, with_eigenvectors=True)</code>","text":"<p>Calculates the phonon frequencies and eigenvectors for the given k-points.</p> <p>Parameters:</p> Name Type Description Default <code>grid</code> <code>SphericalGrid</code> <p>The grid object with the k-points.</p> required <code>with_eigenvectors</code> <code>bool</code> <p>Whether to compute the eigenvectors. Defaults to True.</p> <code>True</code> <p>Returns:</p> Type Description <code>Tuple[ndarray, ndarray]</code> <p>A tuple containing the phonon frequencies and eigenvectors.</p> <ul> <li> <p>The phonon frequencies are represented as a numpy array of shape (n_k,n_modes)</p> </li> <li> <p>The eigenvectors are represented as a numpy array of shape (n_k, n_modes, n_atoms, 3)</p> </li> </ul> <p>where n_k is the number of k-points, n_modes is the number of modes, n_atoms is the number of atoms, and the last index is for the x, y, z components of the eigenvectors.</p> Source code in <code>darkmagic/material.py</code> <pre><code>def get_eig(\n    self, grid: SphericalGrid, with_eigenvectors: bool = True\n) -&gt; Tuple[np.ndarray, np.ndarray]:\n    \"\"\"\n    Calculates the phonon frequencies and eigenvectors for the given k-points.\n\n    Args:\n        grid (SphericalGrid): The grid object with the k-points.\n        with_eigenvectors (bool, optional): Whether to compute the eigenvectors. Defaults to True.\n\n    Returns:\n        A tuple containing the phonon frequencies and eigenvectors.\n\n            * The phonon frequencies are represented as a numpy array of shape (n_k,n_modes)\n\n            * The eigenvectors are represented as a numpy array of shape (n_k, n_modes, n_atoms, 3)\n\n            where n_k is the number of k-points, n_modes is the number of modes,\n            n_atoms is the number of atoms, and the last index is\n            for the x, y, z components of the eigenvectors.\n    \"\"\"\n    k_points = grid.k_frac\n    self.phonopy_file.run_qpoints(k_points, with_eigenvectors=with_eigenvectors)\n\n    mesh_dict = self.phonopy_file.get_qpoints_dict()\n    eigenvectors_pre = mesh_dict.get(\"eigenvectors\", None)\n\n    # Convert from THz (phonopy default for any calculator) to eV\n    omega = const.THz_to_eV * mesh_dict[\"frequencies\"]\n\n    eigenvectors = np.zeros(\n        (len(k_points), self.n_modes, self.n_atoms, 3), dtype=complex\n    )\n    # Need to reshape the eigenvectors from (n_k, n_modes, n_modes)\n    # to (n_k, n_modes, n_atoms, 3)\n    if with_eigenvectors:\n        # TODO: Should rewrite this with a reshape...\n        for q in range(len(k_points)):\n            for nu in range(self.n_modes):\n                eigenvectors[q, nu] = np.array_split(\n                    eigenvectors_pre[q].T[nu], self.n_atoms\n                )\n\n    return omega, eigenvectors\n</code></pre>"},{"location":"reference/darkmagic/material/#darkmagic.material.PhononMaterial.get_W_tensor","title":"<code>get_W_tensor(grid)</code>","text":"<p>Computes the W tensor for the given Monkhorst-Pack grid. The W tensor for atom \\(j\\) is given by: $$ \\mathbf{W}j = \\frac{\\Omega}{4 m_j} \\sum\\nu \\int_\\text{1BZ} \\frac{d^3k}{(2\\pi)^3} \\frac{\\epsilon_{\\nu j \\bm{k}} \\otimes \\epsilon_{\\nu j \\bm{k}}^*}{\\omega_{\\nu \\bm{k}}} $$</p> <p>The Debye-Waller factor can be computed from the W tensor as: $$ W_j(\\bm{q}) = \\bm{q} \\cdot (\\mathbf{W}_j \\bm{q}) $$</p> <p>Parameters:</p> Name Type Description Default <code>grid</code> <code>MonkhorstPackGrid</code> <p>The Monkhorst-Pack grid.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: The W tensor.</p> Source code in <code>darkmagic/material.py</code> <pre><code>def get_W_tensor(self, grid: MonkhorstPackGrid) -&gt; np.ndarray:\n    r\"\"\"\n    Computes the W tensor for the given Monkhorst-Pack grid. The W tensor for atom $j$ is given by:\n    $$\n    \\mathbf{W}_j = \\frac{\\Omega}{4 m_j} \\sum_\\nu \\int_\\text{1BZ} \\frac{d^3k}{(2\\pi)^3} \\frac{\\epsilon_{\\nu j \\bm{k}} \\otimes \\epsilon_{\\nu j \\bm{k}}^*}{\\omega_{\\nu \\bm{k}}}\n    $$\n\n    The Debye-Waller factor can be computed from the W tensor as:\n    $$\n    W_j(\\bm{q}) = \\bm{q} \\cdot (\\mathbf{W}_j \\bm{q})\n    $$\n\n    Args:\n        grid (MonkhorstPackGrid): The Monkhorst-Pack grid.\n\n    Returns:\n        np.ndarray: The W tensor.\n\n    \"\"\"\n    omega, epsilon = self.get_eig(grid)\n    # epsilon is (n_k, n_modes, n_atoms, 3)\n    eps_tensor = np.einsum(\"...i,...j-&gt;...ij\", epsilon, np.conj(epsilon))\n\n    # Sum over all modes and divide by the frequency\n    W = (\n        1\n        / (4 * self.m_atoms[None, :, None, None])\n        * np.sum(eps_tensor / omega[..., None, None, None], axis=1)\n    )\n    # Integrate over the BZ\n    return np.sum(W * grid.weights[:, None, None, None], axis=0) / np.sum(\n        grid.weights\n    )\n</code></pre>"},{"location":"reference/darkmagic/material/#darkmagic.material.MagnonMaterial","title":"<code>MagnonMaterial(name, properties, hamiltonian, m_cell, nodmi=False, noaniso=False)</code>","text":"<p>             Bases: <code>Material</code></p> <p>A class for materials with magnons</p> <p>Attributes:</p> Name Type Description <code>hamiltonian</code> <code>SpinHamiltonian</code> <p>The spin Hamiltonian of the material.</p> <code>n_modes</code> <code>int</code> <p>The number of magnon modes.</p> <code>dispersion</code> <code>MagnonDispersion</code> <p>The magnon dispersion.</p> <p>In the current implementation, the hamiltonian only contains the magnetic atoms and their interactions. So m_cell needs to be specified separately</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the material.</p> required <code>properties</code> <code>MaterialParameters</code> <p>The properties of the material.</p> required <code>hamiltonian</code> <code>SpinHamiltonian</code> <p>The spin Hamiltonian</p> required <code>m_cell</code> <code>float</code> <p>the total mass of all ions in the cell</p> required <code>nodmi</code> <code>bool</code> <p>Whether to include DM interactions.</p> <code>False</code> <code>noaniso</code> <code>bool</code> <p>Whether to include anisotropic exchange.</p> <code>False</code> Source code in <code>darkmagic/material.py</code> <pre><code>def __init__(\n    self,\n    name: str,\n    properties: MaterialParameters,\n    hamiltonian: SpinHamiltonian,\n    m_cell: float,\n    nodmi: bool = False,\n    noaniso: bool = False,\n):\n    \"\"\"\n    Constructor for a magnon material\n\n    In the current implementation, the hamiltonian only\n    contains the magnetic atoms and their interactions.\n    So m_cell needs to be specified separately\n\n    Args:\n        name: The name of the material.\n        properties: The properties of the material.\n        hamiltonian: The spin Hamiltonian\n        m_cell: the total mass of all ions in the cell\n        nodmi: Whether to include DM interactions.\n        noaniso: Whether to include anisotropic exchange.\n    \"\"\"\n    # Ensure the hamiltonian is in the correct units\n    # hamiltonian.cell *= const.Ang_to_inveV\n    # In the future we should have a check that it comes in in units of A\n    # And convert it here\n    self.hamiltonian = hamiltonian\n    n_atoms = len(hamiltonian.magnetic_atoms)\n    self.n_modes = n_atoms\n    self.dispersion = MagnonDispersion(\n        hamiltonian, phase_convention=\"tanner\", nodmi=nodmi, noaniso=noaniso\n    )\n\n    n_atoms = len(hamiltonian.magnetic_atoms)  # Number of magnetic atoms\n    properties.validate_for_magnons(n_atoms)\n    # Atom positions in cartesian coordinates (units of 1/eV)\n    self.xj = np.array(\n        [\n            hamiltonian.get_atom_coordinates(atom, relative=False)\n            for atom in hamiltonian.magnetic_atoms\n        ]\n    )\n    # Spins\n    self.Sj = np.array([atom.spin for atom in hamiltonian.magnetic_atoms])\n    # The vectors for rotating to local coordiante system\n    # TODO: make this an internal variable\n    self.rj = self.dispersion.u\n\n    positions = np.array([a.position for a in hamiltonian.magnetic_atoms])\n    lattice = hamiltonian.cell\n    species = [a.type for a in hamiltonian.magnetic_atoms]\n    structure = Structure(lattice, species, positions)\n\n    m_atoms = [m_cell / n_atoms] * n_atoms\n    super().__init__(name, properties, structure, m_atoms)\n</code></pre>"},{"location":"reference/darkmagic/material/#darkmagic.material.MagnonMaterial.max_dE","title":"<code>max_dE: float</code>  <code>property</code>","text":"<p>TODO: this needs improvement</p> <p>Returns the maximum dE possible for the material. For magnons, we estimate this as roughly 3 times the highest magnon frequency at the Brillouin zone (BZ) boundary. If there are no gapped modes at the gamma point, the maximum dE will be 0.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The maximum dE value.</p> Notes <p>This calculation should be an average over the Brillouin zone (BZ).</p>"},{"location":"reference/darkmagic/material/#darkmagic.material.MagnonMaterial.q_cut","title":"<code>q_cut: float</code>  <code>property</code>","text":"<p>For magnons there is no <code>q_cut</code>, so we just set this to a very large number.</p> <p>Returns:</p> Name Type Description <code>q_cut</code> <code>float</code> <p>a very large number.</p>"},{"location":"reference/darkmagic/material/#darkmagic.material.MagnonMaterial.get_eig","title":"<code>get_eig(grid)</code>","text":"<p>Computes the magnon eigenvalues and eigenvectors (polarization vectors) for a list of k-points.</p> <p>Parameters:</p> Name Type Description Default <code>k</code> <code>ArrayLike</code> <p>The k-point in fractional coordinates.</p> required <p>Returns:</p> Source code in <code>darkmagic/material.py</code> <pre><code>def get_eig(self, grid: SphericalGrid) -&gt; Tuple[np.ndarray, np.ndarray]:\n    \"\"\"\n    Computes the magnon eigenvalues and eigenvectors (polarization vectors) for a list of k-points.\n\n    Args:\n        k (ArrayLike): The k-point in fractional coordinates.\n\n    Returns:\n\n    \"\"\"\n    omegas = np.zeros((grid.nq, self.n_modes))\n    epsilons = np.zeros((grid.nq, self.n_modes, self.n_atoms, 3), dtype=complex)\n\n    # TODO: This is a very slow implementation\n    for ik, k in enumerate(grid.k_cart):\n        omegas[ik, ...], epsilons[ik, ...] = self._get_eig_k(k)\n\n    return omegas, epsilons\n</code></pre>"},{"location":"reference/darkmagic/model/","title":"model","text":""},{"location":"reference/darkmagic/model/#darkmagic.model.Model","title":"<code>Model(name, coeff_prefactor, coeff_func, F_med_prop=None, ref_cross_sect=None, S_chi=0.5, shortname=None)</code>","text":"<p>A class representing a model for dark matter scattering. See the benchmark models for examples on how to define a model.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>The name of the model.</p> <code>coeff_prefactor</code> <code>dict</code> <p>A dictionary of coefficient prefactors (constants).</p> <code>coeff_func</code> <code>dict</code> <p>A dictionary of coefficient functions of the form (grid, m_chi, S_chi) -&gt; np.array.</p> <code>F_med_prop</code> <code>Callable[[SphericalGrid], array]</code> <p>The mediator propagator</p> <code>power_V</code> <code>int</code> <p>The power V</p> <code>S_chi</code> <code>float</code> <p>The value of S_chi.</p> <code>operators</code> <code>dict</code> <p>A dictionary of operators.</p> <code>particles</code> <code>dict</code> <p>A dictionary of particles.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the model.</p> required <code>coeff_prefactor</code> <code>dict</code> <p>A dictionary of coefficient prefactors.</p> required <code>coeff_func</code> <code>dict</code> <p>A dictionary of coefficient functions.</p> required <code>F_med_prop</code> <code>Callable[[SphericalGrid], array] | None</code> <p>A function that calculates the medium flux property. Defaults to None.</p> <code>None</code> <code>ref_cross_sect</code> <code>Callable[[array], array] | None</code> <p>A function that calculates the reference cross section. Defaults to None.</p> <code>None</code> <code>S_chi</code> <code>float</code> <p>DM spin, 1/2 by default.</p> <code>0.5</code> <code>shortname</code> <code>str</code> <p>The short name of the model, used in the output filenames. Defaults to lowercase initials of the model name.</p> <code>None</code> Source code in <code>darkmagic/model.py</code> <pre><code>def __init__(\n    self,\n    name: str,\n    coeff_prefactor: dict,\n    coeff_func: dict,\n    F_med_prop: Callable[[SphericalGrid], np.array] | None = None,\n    ref_cross_sect: Callable[[np.array], np.array] | None = None,\n    S_chi: float = 0.5,\n    shortname: str = None,\n):\n    \"\"\"\n    Constructor for the Model class.\n\n    Args:\n        name (str): The name of the model.\n        coeff_prefactor (dict): A dictionary of coefficient prefactors.\n        coeff_func (dict): A dictionary of coefficient functions.\n        F_med_prop (Callable[[SphericalGrid], np.array] | None, optional): A function that calculates the medium flux property. Defaults to None.\n        ref_cross_sect (Callable[[np.array], np.array] | None, optional): A function that calculates the reference cross section. Defaults to None.\n        S_chi (float, optional): DM spin, 1/2 by default.\n        shortname (str, optional): The short name of the model, used in the output filenames. Defaults to lowercase initials of the model name.\n    \"\"\"\n    self.name = name\n    if shortname is None and self.name is not None:\n        shortname = \"\".join([word[0].lower() for word in name.split()])\n    self.shortname = shortname\n\n    self.S_chi = S_chi\n    self.coeff_prefactor = coeff_prefactor\n    self.coeff_func = coeff_func\n    self.operators, self.particles = self._get_operators_and_particles()\n\n    if F_med_prop is None:\n\n        def ones(grid):\n            return np.ones_like(grid.q_norm)\n\n        F_med_prop = ones\n    self.F_med_prop = F_med_prop\n\n    # Conversion factor to $\\bar{\\sigma}$ in NATURAL UNITS\n    if ref_cross_sect is None:\n\n        def ref_cross_sect(m_chi):\n            return np.ones_like(m_chi)\n\n        ref_cross_sect = ref_cross_sect\n\n    self.ref_cross_sect = ref_cross_sect\n\n    self._validate_coefficients()\n\n    # Unused, for backwards compatibility\n    self.Fmed_power = 0\n    self.power_V = 0\n</code></pre>"},{"location":"reference/darkmagic/model/#darkmagic.model.Model.from_dict","title":"<code>from_dict(d)</code>  <code>classmethod</code>","text":"<p>Create a Model object from a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>d</code> <code>dict</code> <p>The dictionary containing the model information.</p> required <p>Returns:</p> Name Type Description <code>Model</code> <p>The Model object.</p> Source code in <code>darkmagic/model.py</code> <pre><code>@classmethod\ndef from_dict(cls, d: dict):\n    \"\"\"\n    Create a Model object from a dictionary.\n\n    Args:\n        d (dict): The dictionary containing the model information.\n\n    Returns:\n        Model: The Model object.\n    \"\"\"\n    return cls(\n        d[\"name\"],\n        d[\"coeff_prefactor\"],\n        d[\"coeff_func\"],\n        None,  # d[\"F_med_prop\"],\n        S_chi=d[\"S_chi\"],\n        shortname=d[\"shortname\"],\n    )\n</code></pre>"},{"location":"reference/darkmagic/model/#darkmagic.model.Model.to_dict","title":"<code>to_dict(serializable=False)</code>","text":"<p>Convert the Model object to a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>serializable</code> <code>bool</code> <p>Whether to return a serializable dictionary. Defaults to False. This essentially replaces function handles with their names.</p> <code>False</code> <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>The dictionary representation of the Model object.</p> Source code in <code>darkmagic/model.py</code> <pre><code>def to_dict(self, serializable=False) -&gt; dict:\n    \"\"\"\n    Convert the Model object to a dictionary.\n\n    Args:\n        serializable (bool, optional): Whether to return a serializable dictionary. Defaults to False. This essentially replaces function handles with their names.\n\n    Returns:\n        dict: The dictionary representation of the Model object.\n    \"\"\"\n    cf = self.coeff_func\n    if serializable:\n        cf = {\n            alpha: {psi: f.__name__ for psi, f in c.items()}\n            for alpha, c in cf.items()\n        }\n    return {\n        \"name\": self.name,\n        \"coeff_prefactor\": self.coeff_prefactor,\n        \"coeff_func\": cf,\n        # \"F_med_prop\": self.F_med_prop,  # TODO: this isn't written\n        \"S_chi\": self.S_chi,\n        \"shortname\": self.shortname,\n    }\n</code></pre>"},{"location":"reference/darkmagic/model/#darkmagic.model.Model.get_unscreened_coeff","title":"<code>get_unscreened_coeff(alpha, psi, grid, m_chi, S_chi)</code>","text":"<p>Get the unscreened coefficient for a given (alpha, psi) pair.</p> <p>Parameters:</p> Name Type Description Default <code>alpha</code> <code>str</code> <p>The operator ID.</p> required <code>psi</code> <code>str</code> <p>The particle.</p> required <code>grid</code> <code>SphericalGrid</code> <p>The spherical grid.</p> required <code>m_chi</code> <code>float</code> <p>The dark matter mass.</p> required <code>S_chi</code> <code>float</code> <p>The dark matter spin.</p> required <p>Returns:</p> Type Description <code>float</code> <p>The unscreened coefficient \\(c_{\u0007lpha}^{(\\psi)}\\).</p> Source code in <code>darkmagic/model.py</code> <pre><code>def get_unscreened_coeff(\n    self, alpha: str, psi: str, grid: SphericalGrid, m_chi: float, S_chi: float\n) -&gt; float:\n    \"\"\"\n    Get the unscreened coefficient for a given (alpha, psi) pair.\n\n    Args:\n        alpha: The operator ID.\n        psi: The particle.\n        grid: The spherical grid.\n        m_chi: The dark matter mass.\n        S_chi: The dark matter spin.\n\n    Returns:\n        The unscreened coefficient $c_{\\alpha}^{(\\psi)}$.\n    \"\"\"\n    return self.coeff_prefactor[alpha][psi] * self.coeff_func[alpha][psi](\n        grid, m_chi, S_chi\n    )\n</code></pre>"},{"location":"reference/darkmagic/model/#darkmagic.model.Model.compute_screened_coeff","title":"<code>compute_screened_coeff(grid, epsilon, m_chi, S_chi)</code>","text":"<p>Compute the screened coefficients for every (operator, particle) pair.</p> <p>The screening of electron coefficients is done according to $$ c^{(e)}{\\alpha} \\rightarrow \\frac{c^{(e)}{\\alpha}}{\\hat{q} \\cdot (\\epsilon \\hat{q})} $$ and the proton coefficients $$ c^{(p)}{\\alpha} \\rightarrow c^{(p)}{\\alpha} + c^{(e)}_{\\alpha} \\left( 1 - \\frac{1}{\\hat{q} \\cdot (\\epsilon \\hat{q})} \\right) $$</p> <p>Parameters:</p> Name Type Description Default <code>grid</code> <code>SphericalGrid</code> <p>The SphericalGrid object containing all the momentum transfer vectors.</p> required <code>epsilon</code> <code>array</code> <p>The dielectric tensor.</p> required <code>m_chi</code> <code>float</code> <p>The dark matter mass.</p> required <code>S_chi</code> <code>float</code> <p>The dark matter spin.</p> required <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary of the screened coefficients, indexable as alpha, with each element being a np.array of shape (nq,).</p> Source code in <code>darkmagic/model.py</code> <pre><code>def compute_screened_coeff(\n    self, grid: SphericalGrid, epsilon: np.array, m_chi: float, S_chi: float\n) -&gt; dict:\n    r\"\"\"\n    Compute the screened coefficients for every (operator, particle) pair.\n\n    The screening of electron coefficients is done according to\n    $$\n    c^{(e)}_{\\alpha} \\rightarrow \\frac{c^{(e)}_{\\alpha}}{\\hat{q} \\cdot (\\epsilon \\hat{q})}\n    $$\n    and the proton coefficients\n    $$\n    c^{(p)}_{\\alpha} \\rightarrow c^{(p)}_{\\alpha} + c^{(e)}_{\\alpha} \\left( 1 - \\frac{1}{\\hat{q} \\cdot (\\epsilon \\hat{q})} \\right)\n    $$\n\n    Args:\n        grid: The SphericalGrid object containing all the momentum transfer vectors.\n        epsilon: The dielectric tensor.\n        m_chi: The dark matter mass.\n        S_chi: The dark matter spin.\n\n    Returns:\n        A dictionary of the screened coefficients, indexable as [alpha][psi], with each element being a np.array of shape (nq,).\n    \"\"\"\n    q_eps_q = np.sum(grid.qhat_qhat * epsilon[None, :], axis=(-1, -2))\n    screened_coeff = {\n        alpha: {psi: self.coeff_prefactor[alpha][psi] for psi in self.particles}\n        for alpha in self.operators\n    }\n    for alpha, c_alpha in screened_coeff.items():\n        for psi in c_alpha.keys():\n            if psi == \"e\":\n                c_alpha[psi] *= 1 / q_eps_q\n            elif psi == \"p\":\n                # TODO: is this correct?\n                c_alpha[psi] += (1 - 1 / q_eps_q) * c_alpha.get(\"e\", 0)\n            elif psi == \"n\":\n                c_alpha[psi] *= np.ones_like(q_eps_q)\n            # neutrons are unscreened\n            c_alpha[psi] *= self.coeff_func[alpha][psi](grid, m_chi, S_chi)\n\n    return screened_coeff\n</code></pre>"},{"location":"reference/darkmagic/model/#darkmagic.model.Potential","title":"<code>Potential(model)</code>","text":"<p>Class for evaluating the potential for a given model.</p> <p>TODO: needs a good bit of cleanup and rethinking. Maybe this should be a subclass of model? TODO: all terms except V1_00 are written correctly but don't work with an array of q's as they should. (Painful) work in progress.</p> <p>Attributes:</p> Name Type Description <code>operators</code> <code>set</code> <p>The set of operators.</p> <code>particles</code> <code>set</code> <p>The set of particles.</p> <code>c</code> <code>Callable[[SphericalGrid, array, float, float], array]</code> <p>The function to compute the screened coefficients.</p> <code>needs_g1</code> <code>bool</code> <p>Whether the G1 velocity integrals are needed.</p> <code>needs_g2</code> <code>bool</code> <p>Whether the G2 velocity integrals are needed.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Model</code> <p>The model for which to evaluate the potential.</p> required Source code in <code>darkmagic/model.py</code> <pre><code>def __init__(self, model: Model):\n    \"\"\"\n    Constructor for the Potential class.\n\n    Args:\n        model (Model): The model for which to evaluate the potential.\n    \"\"\"\n    self.operators = model.operators\n    self.particles = model.particles\n    self.c = model.compute_screened_coeff\n</code></pre>"},{"location":"reference/darkmagic/model/#darkmagic.model.Potential.eval_V","title":"<code>eval_V(grid, material, m_chi, S_chi)</code>","text":"<p>Evaluate the full potential V_j(q) for the given grid and material</p> <p>Parameters:</p> Name Type Description Default <code>grid</code> <code>SphericalGrid</code> <p>The grid of momentum transfer vectors.</p> required <code>material</code> <code>Material</code> <p>The material object</p> required <code>m_chi</code> <code>float</code> <p>The dark matter mass.</p> required <code>S_chi</code> <code>float</code> <p>The dark matter spin.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>A dictionary of the potential terms, indexed by the term type.</p> Source code in <code>darkmagic/model.py</code> <pre><code>def eval_V(\n    self, grid: SphericalGrid, material: Material, m_chi: float, S_chi: float\n) -&gt; dict:\n    \"\"\"\n    Evaluate the full potential V_j(q) for the given grid and material\n\n    Args:\n        grid (SphericalGrid): The grid of momentum transfer vectors.\n        material (Material): The material object\n        m_chi (float): The dark matter mass.\n        S_chi (float): The dark matter spin.\n\n    Returns:\n        dict: A dictionary of the potential terms, indexed by the term type.\n    \"\"\"\n\n    # Get all the V functions\n    full_V = self._get_full_V()\n\n    # Prepare the output dictionary\n    terms = {key for alpha in self.operators for key in full_V[alpha].keys()}\n    V = {t: self._get_zeros(t, material.n_atoms, grid) for t in terms}\n\n    # Determine which velocity integrals are needed\n    self.needs_g1 = bool(\"12\" or \"11\" in terms)\n    self.needs_g2 = \"20\" in terms\n\n    def get_slice(t):\n        return (slice(None),) + (None,) * (V[t].ndim - 1)\n\n    coeff = self.c(grid, material.epsilon, m_chi, S_chi)\n    # TODO: write this nicer\n    for psi in self.particles:\n        for alpha in self.operators:\n            C = coeff[alpha][psi]\n            for t, V_func in full_V[alpha].items():\n                V[t] += C[get_slice(t)] * V_func(grid, psi, material, m_chi, S_chi)\n    return V\n</code></pre>"},{"location":"reference/darkmagic/model/#darkmagic.model.MissingCoefficientFunctionException","title":"<code>MissingCoefficientFunctionException</code>","text":"<p>             Bases: <code>Exception</code></p> <p>Raised when an operator has a non-zero coefficient prefactor but no coefficient function.</p>"},{"location":"reference/darkmagic/model/#darkmagic.model.ExtraCoefficientFunctionWarning","title":"<code>ExtraCoefficientFunctionWarning</code>","text":"<p>             Bases: <code>Warning</code></p> <p>Warning that an operator has a coefficient function but no non-zero coefficient prefactor, so the operator will be ignored.</p>"},{"location":"reference/darkmagic/model/#darkmagic.model.UnsupportedOperatorException","title":"<code>UnsupportedOperatorException</code>","text":"<p>             Bases: <code>Exception</code></p> <p>Raised when an operator is not supported.</p>"},{"location":"reference/darkmagic/numerics/","title":"numerics","text":""},{"location":"reference/darkmagic/numerics/#darkmagic.numerics.MonkhorstPackGrid","title":"<code>MonkhorstPackGrid(N_grid, material, shift=True, use_sym=False)</code>","text":"<p>A class representing a Monkhorst-Pack grid for Brillouin zone sampling.</p> <p>Attributes:</p> Name Type Description <code>k_frac</code> <code>ndarray</code> <p>The fractional coordinates of the k vectors.</p> <code>weights</code> <code>ndarray</code> <p>The weights of the k vectors.</p> <p>N_grid (ArrayLike): The number of grid points along each reciprocal lattice vector. material (Material): The material for which the grid is generated. shift (bool): Whether to shift the grid. Defaults to a shifted grid to avoid singularities in DWF. use_sym (bool, optional): Whether to use symmetry to reduce the number of grid points. Defaults to False. The W tensor is only calculated once so this isn't necessary to use and causes issues.</p> Source code in <code>darkmagic/numerics.py</code> <pre><code>def __init__(\n    self,\n    N_grid: ArrayLike,\n    material: Material,\n    shift: bool = True,\n    use_sym: bool = False,\n):\n    \"\"\"\n    Constructor for the MonkhorstPackGrid class.\n\n    N_grid (ArrayLike): The number of grid points along each reciprocal lattice vector.\n    material (Material): The material for which the grid is generated.\n    shift (bool): Whether to shift the grid. Defaults to a shifted grid to avoid singularities in DWF.\n    use_sym (bool, optional): Whether to use symmetry to reduce the number of grid points. Defaults to False. The W tensor is only calculated once so this isn't necessary to use and causes issues.\n    \"\"\"\n    shift = [1, 1, 1] if shift else [0, 0, 0]\n    # SGA struggles with the struct in 1/eV, so we scale back to ang\n    struct = deepcopy(material.structure)\n    struct.scale_lattice(struct.volume * (const.inveV_to_Ang) ** 3)\n    sga = SpacegroupAnalyzer(struct)\n    if use_sym:\n        points = sga.get_ir_reciprocal_mesh(N_grid, is_shift=shift)\n        self.k_frac, self.weights = map(np.array, zip(*points))\n    else:\n        self.k_frac, _ = sga.get_ir_reciprocal_mesh_map(N_grid, is_shift=shift)\n        self.weights = np.ones_like(self.k_frac[:, 0])\n</code></pre>"},{"location":"reference/darkmagic/numerics/#darkmagic.numerics.SphericalGrid","title":"<code>SphericalGrid(m_chi, v_e, use_q_cut, N_grid, material)</code>","text":"<p>Represents a spherical grid used for numerical calculations in DarkMAGIC.</p> <p>Attributes:</p> Name Type Description <code>nq</code> <code>int</code> <p>The number of q points.</p> <code>q_max</code> <code>float</code> <p>The maximum value of the q vector (eV).</p> <code>q_cart</code> <code>ndarray</code> <p>The Cartesian coordinates of the q vectors (eV).</p> <code>q_frac</code> <code>ndarray</code> <p>The fractional coordinates of the q vectors.</p> <code>q_norm</code> <code>ndarray</code> <p>The norms of the q vectors (eV).</p> <code>q_hat</code> <code>ndarray</code> <p>The unit vectors of the q vectors.</p> <code>G_cart</code> <code>ndarray</code> <p>The Cartesian coordinates of the G vectors (eV).</p> <code>G_frac</code> <code>ndarray</code> <p>The fractional coordinates of the G vectors.</p> <code>jacobian</code> <code>ndarray</code> <p>The Jacobian determinant for the spherical grid.</p> <code>k_frac</code> <code>ndarray</code> <p>The fractional coordinates of the k vectors.</p> <code>k_cart</code> <code>ndarray</code> <p>The Cartesian coordinates of the k vectors.</p> <p>Parameters:</p> Name Type Description Default <code>m_chi</code> <code>float</code> <p>The mass of the dark matter particle.</p> required <code>v_e</code> <code>ArrayLike</code> <p>The velocity of the Earth.</p> required <code>use_q_cut</code> <code>bool</code> <p>Whether to use the q_cut value.</p> required <code>N_grid</code> <code>ArrayLike</code> <p>The number of grid points (radial, azimuthal, polar)</p> required <code>material</code> <code>Material</code> <p>A Material object containing the material properties.</p> required Source code in <code>darkmagic/numerics.py</code> <pre><code>def __init__(\n    self,\n    m_chi: float,\n    v_e: ArrayLike,\n    use_q_cut: bool,\n    N_grid: ArrayLike,\n    material: Material,\n):\n    \"\"\"\n    Spherical grid constructor.\n\n    Args:\n        m_chi: The mass of the dark matter particle.\n        v_e: The velocity of the Earth.\n        use_q_cut: Whether to use the q_cut value.\n        N_grid: The number of grid points (radial, azimuthal, polar)\n        material: A Material object containing the material properties.\n    \"\"\"\n    # Get q and G vectors\n    q_cut = material.q_cut if use_q_cut else 1e10\n    self.q_max = min(2 * m_chi * (const.VESC + const.VE), q_cut)\n    self.q_cart, self.q_frac = self._get_q_points(\n        N_grid, m_chi, v_e, material.recip_cart_to_frac\n    )\n    self.nq = self.q_cart.shape[0]\n    # These show up often so it's efficient to compute them only once\n    self.q_norm = LA.norm(self.q_cart, axis=1)\n    self.q_hat = self.q_cart / self.q_norm[:, None]\n\n    # Get G-vectors\n    self.G_cart, self.G_frac = self._get_G_vectors(material.recip_frac_to_cart)\n    # Deriving this is straightforward, remember we're sampling\n    # with a power of 2 in the q direction, hence the square roots on |q|\n    self.jacobian = 8 * np.pi * self.q_norm ** (5 / 2) * self.q_max ** (1 / 2)\n    # Volume element dV = d^3q J(q) / (2pi)^3 / N^3\n    self.vol_element = self.jacobian / ((2 * np.pi) ** 3 * np.prod(N_grid))\n\n    # Get the k-vectors\n    self.k_frac = self.q_frac - self.G_frac\n    self.k_cart = np.matmul(self.k_frac, material.recip_frac_to_cart)\n\n    # Outer product of qhat with itself is frequently used\n    self._qhat_qhat = None\n</code></pre>"},{"location":"reference/darkmagic/numerics/#darkmagic.numerics.Numerics","title":"<code>Numerics(N_grid=None, N_DWF_grid=None, bin_width=0.001, use_q_cut=True, use_special_mesh=False, threshold=0, power_abc=None)</code>","text":"<p>A class that represents the numerical parameters for DarkMAGIC calculations.</p> <p>Parameters:</p> Name Type Description Default <code>N_grid</code> <code>ArrayLike</code> <p>The number of grid points in each dimension. Defaults to [20, 10, 10].</p> <code>None</code> <code>power_abc</code> <code>ArrayLike</code> <p>The power of each dimension in the grid. Defaults to [2, 1, 1].</p> <code>None</code> <code>N_DWF_grid</code> <code>ArrayLike</code> <p>The number of grid points in each dimension for the density-weighted Fermi grid. Defaults to [20, 20, 20].</p> <code>None</code> <code>bin_width</code> <code>float</code> <p>The width of the bin. Defaults to 1e-3 (1 meV).</p> <code>0.001</code> <code>use_q_cut</code> <code>bool</code> <p>Whether to use a cutoff in momentum space. Defaults to True.</p> <code>True</code> <code>use_special_mesh</code> <code>bool</code> <p>Whether to use a special mesh for the grid. Defaults to False.</p> <code>False</code> <p>Attributes:</p> Name Type Description <code>N_grid</code> <code>ndarray</code> <p>The number of grid points in the spherical grid used to sample the momentum transfer (radial, azimuthal, polar).</p> <code>power_abc</code> <code>ndarray</code> <p>The power of each dimension in the grid (currently unsued)</p> <code>N_DWF_grid</code> <code>ndarray</code> <p>The size of the Monkhorst-Pack grid used to compute the Debye-Waller factor.</p> <code>bin_width</code> <code>float</code> <p>The width of the energy bin. Rebinning to larger bins is possible in postprocessing.</p> <code>use_q_cut</code> <code>bool</code> <p>Whether to use a cutoff for the momentum transfer from DM. If False, the cutoff is set to the maximum possible value \\(2 m_{\\chi} (v_{\\text{esc}} + v_{\\text{e}})\\).</p> <code>use_special_mesh</code> <code>bool</code> <p>Whether to use a special mesh for the spherical grid (currently unused)</p> <p>Methods:</p> Name Description <code>get_grid</code> <p>float, v_e: ArrayLike, material: Material) -&gt; SphericalGrid: Returns the spherical grid for the given dark matter mass, Earth velocity, and material.</p> <code>get_DWF_grid</code> <p>Material) -&gt; MonkhorstPackGrid: Returns the Monkhorst-Pack grid for computing the Debye-Waller factor.</p> <p>Parameters:</p> Name Type Description Default <code>N_grid</code> <code>ndarray</code> <p>The number of grid points in the spherical grid used to sample the momentum transfer (radial, azimuthal, polar).</p> <code>None</code> <code>power_abc</code> <code>ndarray</code> <p>The power of each dimension in the grid (currently unsued)</p> <code>None</code> <code>N_DWF_grid</code> <code>ndarray</code> <p>The size of the Monkhorst-Pack grid used to compute the Debye-Waller factor.</p> <code>None</code> <code>bin_width</code> <code>float</code> <p>The width of the energy bin. Rebinning to larger bins is possible in postprocessing.</p> <code>0.001</code> <code>use_q_cut</code> <code>bool</code> <p>Whether to use a cutoff for the momentum transfer from DM. If False, the cutoff is set to the maximum possible value \\(2 m_{\\chi} (v_{\\text{esc}} + v_{\\text{e}})\\).</p> <code>True</code> <code>use_special_mesh</code> <code>bool</code> <p>Whether to use a special mesh for the spherical grid (currently unused)</p> <code>False</code> <code>threshold</code> <code>float</code> <p>unused, DarkMAGIC does not impose any thresholds during the actual calculation. Maintained for backwards compatibility.</p> <code>0</code> Source code in <code>darkmagic/numerics.py</code> <pre><code>def __init__(\n    self,\n    N_grid: ArrayLike = None,\n    N_DWF_grid: ArrayLike = None,\n    bin_width: float = 1e-3,\n    use_q_cut: bool = True,\n    use_special_mesh: bool = False,\n    threshold=0,\n    power_abc: ArrayLike = None,\n):\n    r\"\"\"\n    Constructor for the Numerics class.\n\n    Args:\n        N_grid (ndarray): The number of grid points in the spherical grid used to sample the momentum transfer (radial, azimuthal, polar).\n        power_abc (ndarray): The power of each dimension in the grid (currently unsued)\n        N_DWF_grid (ndarray): The size of the Monkhorst-Pack grid used to compute the Debye-Waller factor.\n        bin_width (float): The width of the energy bin. Rebinning to larger bins is possible in postprocessing.\n        use_q_cut (bool): Whether to use a cutoff for the momentum transfer from DM. If False, the cutoff is set to the maximum possible value $2 m_{\\chi} (v_{\\text{esc}} + v_{\\text{e}})$.\n        use_special_mesh (bool): Whether to use a special mesh for the spherical grid (currently unused)\n        threshold (float): unused, DarkMAGIC does not impose any thresholds during the actual calculation. Maintained for backwards compatibility.\n    \"\"\"\n    if N_grid is None:\n        N_grid = [20, 10, 10]\n    if power_abc is None:\n        power_abc = [2, 1, 1]\n    if N_DWF_grid is None:\n        N_DWF_grid = [20, 20, 20]\n    self.N_grid = np.array(N_grid)\n    self._power_abc = np.array(power_abc)\n    self.N_DWF_grid = np.array(N_DWF_grid)\n    self.bin_width = bin_width\n    self.use_q_cut = use_q_cut\n    self._use_special_mesh = use_special_mesh\n    self._threshold = threshold\n</code></pre>"},{"location":"reference/darkmagic/numerics/#darkmagic.numerics.Numerics.from_dict","title":"<code>from_dict(d)</code>  <code>classmethod</code>","text":"<p>Create a Numerics object from a dictionary.</p> <p>Parameters:</p> Name Type Description Default <code>d</code> <code>dict</code> <p>The dictionary containing the numerical parameters.</p> required <p>Returns:</p> Name Type Description <code>Numerics</code> <p>The Numerics object.</p> Source code in <code>darkmagic/numerics.py</code> <pre><code>@classmethod\ndef from_dict(cls, d: dict):\n    \"\"\"\n    Create a Numerics object from a dictionary.\n\n    Args:\n        d (dict): The dictionary containing the numerical parameters.\n\n    Returns:\n        Numerics: The Numerics object.\n    \"\"\"\n    return cls(\n        d[\"N_grid\"],\n        d[\"N_DWF_grid\"],\n        d[\"bin_width\"],\n        d[\"use_q_cut\"],\n        d[\"_use_special_mesh\"],\n        d[\"_threshold\"],\n        d[\"_power_abc\"],\n    )\n</code></pre>"},{"location":"reference/darkmagic/numerics/#darkmagic.numerics.Numerics.to_dict","title":"<code>to_dict()</code>","text":"<p>Convert the Numerics object to a dictionary.</p> <p>Returns:</p> Name Type Description <code>dict</code> <p>The dictionary containing the numerical parameters.</p> Source code in <code>darkmagic/numerics.py</code> <pre><code>def to_dict(self):\n    \"\"\"\n    Convert the Numerics object to a dictionary.\n\n    Returns:\n        dict: The dictionary containing the numerical parameters.\n    \"\"\"\n    return {\n        \"N_grid\": self.N_grid,\n        \"N_DWF_grid\": self.N_DWF_grid,\n        \"bin_width\": self.bin_width,\n        \"use_q_cut\": self.use_q_cut,\n        \"_use_special_mesh\": self._use_special_mesh,\n        \"_threshold\": self._threshold,\n        \"_power_abc\": self._power_abc,\n    }\n</code></pre>"},{"location":"reference/darkmagic/numerics/#darkmagic.numerics.Numerics.get_grid","title":"<code>get_grid(m_chi, v_e, material)</code>","text":"<p>Returns the spherical grid object.</p> <p>Parameters:</p> Name Type Description Default <code>m_chi</code> <code>float</code> <p>The mass of the dark matter particle.</p> required <code>v_e</code> <code>ArrayLike</code> <p>The velocity of the Earth.</p> required <code>material</code> <code>Material</code> <p>The material object.</p> required <p>Returns:</p> Name Type Description <code>SphericalGrid</code> <code>SphericalGrid</code> <p>The spherical grid object.</p> Source code in <code>darkmagic/numerics.py</code> <pre><code>def get_grid(\n    self, m_chi: float, v_e: ArrayLike, material: Material\n) -&gt; SphericalGrid:\n    \"\"\"\n    Returns the spherical grid object.\n\n    Args:\n        m_chi (float): The mass of the dark matter particle.\n        v_e (ArrayLike): The velocity of the Earth.\n        material (Material): The material object.\n\n    Returns:\n        SphericalGrid: The spherical grid object.\n    \"\"\"\n    return SphericalGrid(m_chi, v_e, self.use_q_cut, self.N_grid, material)\n</code></pre>"},{"location":"reference/darkmagic/numerics/#darkmagic.numerics.Numerics.get_DWF_grid","title":"<code>get_DWF_grid(material)</code>","text":"<p>Returns the density-weighted Fermi grid object.</p> <p>Parameters:</p> Name Type Description Default <code>material</code> <code>Material</code> <p>The material object.</p> required <p>Returns:</p> Name Type Description <code>MonkhorstPackGrid</code> <code>MonkhorstPackGrid</code> <p>The density-weighted Fermi grid object.</p> Source code in <code>darkmagic/numerics.py</code> <pre><code>def get_DWF_grid(self, material: Material) -&gt; MonkhorstPackGrid:\n    \"\"\"\n    Returns the density-weighted Fermi grid object.\n\n    Args:\n        material (Material): The material object.\n\n    Returns:\n        MonkhorstPackGrid: The density-weighted Fermi grid object.\n    \"\"\"\n    return MonkhorstPackGrid(self.N_DWF_grid, material)\n</code></pre>"},{"location":"reference/darkmagic/parallel/","title":"parallel","text":""},{"location":"reference/darkmagic/parallel/#darkmagic.parallel.distribute_load","title":"<code>distribute_load(n_proc, masses, times)</code>","text":"<p>This function distributes the load of jobs across the available processors. It attempts to balance the load as much as possible.</p> Source code in <code>darkmagic/parallel.py</code> <pre><code>def distribute_load(n_proc, masses, times):\n    \"\"\"\n    This function distributes the load of jobs across the available processors.\n    It attempts to balance the load as much as possible.\n    \"\"\"\n    # TODO: change to logging\n    print(\"Distributing load among processors.\")\n    # Our jobs list is a list of tuples, where each tuple is a pair of (mass, time) indices\n    total_job_list = np.array(\n        list(itertools.product(range(len(masses)), range(len(times))))\n    )\n    n_jobs = len(total_job_list)\n\n    base_jobs_per_proc = n_jobs // n_proc  # each processor has at least this many jobs\n    extra_jobs = 1 if n_jobs % n_proc else 0  # might need 1 more job on some processors\n    # Note a fan of using a sentinel value to indicate a \"do nothing\" job\n    job_list = JOB_SENTINEL * np.ones(\n        (n_proc, base_jobs_per_proc + extra_jobs, 2), dtype=int\n    )\n\n    for i in range(n_jobs):\n        proc_index = i % n_proc\n        job_index = i // n_proc\n        job_list[proc_index, job_index] = total_job_list[i]\n\n    if n_jobs &gt; n_proc:\n        print(\"Number of jobs exceeds the number of processors.\")\n        print(f\"Baseline number of jobs per processor: {str(base_jobs_per_proc)}\")\n        print(\n            \"Remaining processors with one extra job: \"\n            + str(n_jobs - n_proc * base_jobs_per_proc)\n        )\n    elif n_jobs &lt; n_proc:\n        print(\"Number of jobs is fewer than the number of processors.\")\n        print(\"Consider reducing the number of processors for more efficiency.\")\n        print(f\"Total number of jobs: {n_jobs}\")\n    else:\n        print(\"Number of jobs matches the number of processors. Maximally parallized.\")\n\n    return job_list\n</code></pre>"},{"location":"reference/darkmagic/rate/","title":"rate","text":""},{"location":"reference/darkmagic/rate/#darkmagic.rate.SingleRateCalc","title":"<code>SingleRateCalc(m_chi, v_e, material, model, numerics)</code>","text":"<p>             Bases: <code>ABC</code></p> <p>An abstract class for calculating rates at a given mass and earth velocity</p> Source code in <code>darkmagic/rate.py</code> <pre><code>def __init__(\n    self,\n    m_chi: float,\n    v_e: ArrayLike,\n    material: Material,\n    model: Model,\n    numerics: Numerics,\n):\n    self.m_chi = m_chi\n    self.v_e = v_e  # self.compute_ve(time) if time is not None else v_e\n    self.material = material\n    self.model = model\n    self.numerics = numerics\n    self.grid = numerics.get_grid(m_chi, self.v_e, material)\n    self.dwf_grid = numerics.get_DWF_grid(material)\n</code></pre>"},{"location":"reference/darkmagic/rate/#darkmagic.rate.SingleRateCalc.calculate_rate","title":"<code>calculate_rate()</code>","text":"<p>Computes the differential rate</p> Source code in <code>darkmagic/rate.py</code> <pre><code>def calculate_rate(\n    self,\n):\n    \"\"\"\n    Computes the differential rate\n    \"\"\"\n\n    # (nq, nmodes) and (nq, nmodes, natoms, 3)\n    omegas, epsilons = self.material.get_eig(self.grid)\n\n    # Compute \\Sigma_{\\nu}(q)\n    sigma_q_nu = self.calculate_sigma_q_nu(omegas, epsilons)\n\n    # Integrate to get deltaR\n    deltaR = (\n        (1 / self.material.m_cell)\n        * (const.rho_chi / self.m_chi)\n        * self.grid.vol_element[:, None]\n        * self.model.F_med_prop(self.grid)[:, None] ** 2\n        * sigma_q_nu\n    )\n\n    # TODO: the names here aren't great\n    max_bin_num = math.ceil(self.material.max_dE / self.numerics.bin_width)\n    bin_num = np.floor((omegas) / self.numerics.bin_width).astype(int)\n    # Each bin has the rate from processes of energies within that bin\n    diff_rate = np.zeros(max_bin_num)\n    np.add.at(diff_rate, bin_num, deltaR)\n    # Integrate over q to get rate from different modes\n    binned_rate = np.sum(deltaR, axis=0)\n    # Sum over modes to get total rate\n    total_rate = np.sum(diff_rate)\n\n    return [diff_rate, binned_rate, total_rate]\n</code></pre>"},{"location":"reference/darkmagic/rate/#darkmagic.rate.MagnonScatterRate","title":"<code>MagnonScatterRate(m_chi, v_e, material, model, numerics)</code>","text":"<p>             Bases: <code>SingleRateCalc</code></p> <p>Class for calculating the differential rate for magnon scattering</p> Source code in <code>darkmagic/rate.py</code> <pre><code>def __init__(\n    self,\n    m_chi: float,\n    v_e: ArrayLike,\n    material: Material,\n    model: Model,\n    numerics: Numerics,\n):\n    self.m_chi = m_chi\n    self.v_e = v_e  # self.compute_ve(time) if time is not None else v_e\n    self.material = material\n    self.model = model\n    self.numerics = numerics\n    self.grid = numerics.get_grid(m_chi, self.v_e, material)\n    self.dwf_grid = numerics.get_DWF_grid(material)\n</code></pre>"},{"location":"reference/darkmagic/rate/#darkmagic.rate.PhononScatterRate","title":"<code>PhononScatterRate(m_chi, v_e, material, model, numerics)</code>","text":"<p>             Bases: <code>SingleRateCalc</code></p> <p>Class for calculating the differential rate for phonon scattering</p> Source code in <code>darkmagic/rate.py</code> <pre><code>def __init__(\n    self,\n    m_chi: float,\n    v_e: ArrayLike,\n    material: Material,\n    model: Model,\n    numerics: Numerics,\n):\n    self.m_chi = m_chi\n    self.v_e = v_e  # self.compute_ve(time) if time is not None else v_e\n    self.material = material\n    self.model = model\n    self.numerics = numerics\n    self.grid = numerics.get_grid(m_chi, self.v_e, material)\n    self.dwf_grid = numerics.get_DWF_grid(material)\n</code></pre>"},{"location":"reference/darkmagic/v_integrals/","title":"v_integrals","text":""},{"location":"reference/darkmagic/v_integrals/#darkmagic.v_integrals.MBDistribution","title":"<code>MBDistribution(grid, omega, m_chi, v_e)</code>","text":"<p>Class for truncated Maxwell-Boltzmann distribution</p> Source code in <code>darkmagic/v_integrals.py</code> <pre><code>def __init__(self, grid, omega, m_chi, v_e) -&gt; None:\n    self.grid = grid\n    self.omega = omega\n    self.m_chi = m_chi\n    self.v_e = np.array(v_e)\n\n    # Internal variables\n    self._v_minus = None\n    self._G0 = None\n    self._G1 = None\n    self._G2 = None\n    self._F = None\n    self._X = None\n    self._eye_minus_qhat_qhat = None\n</code></pre>"},{"location":"reference/darkmagic/v_integrals/#darkmagic.v_integrals.MBDistribution.v_minus","title":"<code>v_minus</code>  <code>property</code>","text":"<p>Computes v_minus = min(|v_star|, Vesc) for each (q, omega) pair q: numpy array of shape (n_q, 3), momentum transfer omega: 2D numpy array of shape (n_q, n_modes), eigenmodes m_chi: float, DM mass v_e: vector, lab frame velocity of earth</p>"},{"location":"reference/darkmagic/v_integrals/#darkmagic.v_integrals.MBDistribution.G0","title":"<code>G0</code>  <code>property</code>","text":"<p>Computes the G0 integral for each (q, omega) pair See Eq. C9 in EFT paper (2009.13534)</p>"},{"location":"reference/darkmagic/v_integrals/#darkmagic.v_integrals.MBDistribution.G1","title":"<code>G1</code>  <code>property</code>","text":"<p>Computes the g1 integral for each (q, omega) pair. See Eq. C11 in EFT paper (2009.13534). Note that my definition here is slightly different from that equation. See formalism notes.</p> <p>TODO: update this docstring with all the equations.</p> <p>The result is a 3D array of shape (n_q, n_modes, 3) (i.e., for each q-point and mode, we get a 3-vector)</p> <p>This integral is equivalent to</p> \\[ g1 = (v_star \\hat{q} - v_e - \\vec{q}/2/m_chi) * g0 \\] this is defined slightly differently in the original <p>PhonoDark. Specifically,</p> \\[ g1 = (v_star R[:,2] - v_e) * g0 \\] <p>where R is a matrix that rotates \\hat{q} to lie along the z-axis</p>"},{"location":"reference/darkmagic/v_integrals/#darkmagic.v_integrals.MBDistribution.G2","title":"<code>G2</code>  <code>property</code>","text":"<p>Computes the g2 integral for each (q, omega) pair. See Eq. C14 in EFT paper (2009.13534). Note that my definition here is slightly different, see the formalism notes.</p> <p>TODO: update this with all the equations</p> <p>The result is a 4D array of shape (n_q, n_modes, 3, 3) (i.e., for each q-point and mode, we get a 3x3 matrix)</p> <p>This suffers from a similar problem to g1, the definition in PhonoDark is quite different from the paper (including the definition of what I call F below) and I don't know how to reconcile them. It also invovles a rotation, like in g1.</p>"},{"location":"reference/darkmagic/v_integrals/#darkmagic.v_integrals.MBDistribution.F","title":"<code>F</code>  <code>property</code>","text":"<p>Computes the very last term of Eq. (C14) in the EFT paper (2009.13534) This is the term that multiplies (1 - qhat \\otimes qhat) in the g2 integral</p>"},{"location":"reference/darkmagic/v_integrals/#darkmagic.v_integrals.MBDistribution.X","title":"<code>X</code>  <code>property</code>","text":"<p>Computes the X vector for each (q, omega) pair</p> \\[ X = (\\omega / |q|) \\hat{q} - (\\mathbb{1} - \\hat{q} \\otimes \\hat{q}) v_e \\] <p>The result is a 3D array of shape (n_q, n_modes, 3)</p>"},{"location":"reference/darkmagic/v_integrals/#darkmagic.v_integrals.MBDistribution.eye_minus_qhat_qhat","title":"<code>eye_minus_qhat_qhat</code>  <code>property</code>","text":"<p>Computes the (3x3) matrix (1 - qhat \\otimes qhat) for each q-point The result is a 3D array of shape (n_q, 3, 3)</p>"},{"location":"reference/darkmagic/benchmark_models/","title":"benchmark_models","text":""},{"location":"reference/darkmagic/benchmark_models/anapole/","title":"anapole","text":""},{"location":"reference/darkmagic/benchmark_models/anapole/#darkmagic.benchmark_models.anapole.get_model","title":"<code>get_model()</code>","text":"<p>TODO: Add docstring.</p> Source code in <code>darkmagic/benchmark_models/anapole.py</code> <pre><code>def get_model() -&gt; Model:\n    \"\"\"\n    TODO: Add docstring.\n    \"\"\"\n    coeff_prefactor = {\n        \"8a\": {\n            \"e\": 1 / 2,  # factor of 1/2 in paper\n            \"p\": -1 / 2,  # Factor of 1/2 in paper * (-1)\n        },\n        \"8b\": {\n            \"e\": 1 / 2,  # factor of 1/2 in paper\n            \"p\": -1 / 2,  # Factor of 1/2 in paper * (-1)\n        },\n        \"9\": {\n            \"e\": -const.mu_tilde_e / 2,  # -mu_tilde_e/2\n            \"p\": const.mu_tilde_p / 2,  # -mu_tilde_p/2 * (-1)\n        },\n    }\n\n    coeff_func = {\n        \"8a\": {\"e\": q_sq_on_mchi_sq, \"p\": q_sq_on_mchi_sq},\n        \"8b\": {\"e\": q_sq_on_mchi_sq, \"p\": q_sq_on_mchi_sq},\n        \"9\": {\"e\": q_sq_on_mchi_sq, \"p\": q_sq_on_mchi_sq},\n    }\n\n    def reference_cross_section(m_chi: float) -&gt; float:\n        return (\n            np.pi\n            / 6\n            * 1\n            / (const.alphaEM**2 * const.m_e**2 * reduced_mass(m_chi, const.m_e) ** 2)\n        )\n\n    return Model(\"Anapole\", coeff_prefactor, coeff_func)\n</code></pre>"},{"location":"reference/darkmagic/benchmark_models/hadrophilic_scalar_mediator/","title":"hadrophilic_scalar_mediator","text":""},{"location":"reference/darkmagic/benchmark_models/hadrophilic_scalar_mediator/#darkmagic.benchmark_models.hadrophilic_scalar_mediator.get_model","title":"<code>get_model(mass)</code>","text":"<p>TODO: Add docstring.</p> Source code in <code>darkmagic/benchmark_models/hadrophilic_scalar_mediator.py</code> <pre><code>def get_model(mass: str) -&gt; Model:\n    \"\"\"\n    TODO: Add docstring.\n    \"\"\"\n    coeff_prefactor = {\n        \"1\": {\"e\": 0, \"p\": 1, \"n\": 1},\n    }\n\n    coeff_func = {\n        \"1\": {\"p\": one, \"n\": one},\n    }\n\n    if mass == \"heavy\":\n\n        def F_mediator_propagator(grid: SphericalGrid) -&gt; np.array:\n            return np.ones_like(grid.q_norm)\n\n        def reference_cross_section(m_chi: np.array) -&gt; np.array:\n            return np.pi * reduced_mass(m_chi, const.m_n) ** (-2)\n    elif mass == \"light\":\n\n        def F_mediator_propagator(grid: SphericalGrid) -&gt; np.array:\n            return grid.q_norm ** (-2)\n\n        def reference_cross_section(m_chi: np.array) -&gt; np.array:\n            q0 = m_chi * const.V0\n            return np.pi * reduced_mass(m_chi, const.m_n) ** (-2) * (q0) ** 4\n\n    else:\n        raise ValueError(\n            \"Unknown mass for the hadrophilic scalar mediator. \"\n            \"Only 'light' and 'heavy' are supported.\"\n        )\n\n    return Model(\n        f\"{mass.capitalize()} Hadrophilic Scalar Mediator\",\n        coeff_prefactor,\n        coeff_func,\n        F_mediator_propagator,\n        reference_cross_section,\n        shortname=f\"{mass[0]}sm\",\n    )\n</code></pre>"},{"location":"reference/darkmagic/benchmark_models/magnetic_dipole/","title":"magnetic_dipole","text":""},{"location":"reference/darkmagic/benchmark_models/magnetic_dipole/#darkmagic.benchmark_models.magnetic_dipole.get_model","title":"<code>get_model()</code>","text":"<p>TODO: Add docstring.</p> Source code in <code>darkmagic/benchmark_models/magnetic_dipole.py</code> <pre><code>def get_model() -&gt; Model:\n    \"\"\"\n    TODO: Add docstring.\n    \"\"\"\n    coeff_prefactor = {\n        \"1\": {\"e\": 1 / 4, \"p\": -1 / 4, \"n\": 0},\n        \"4\": {\"e\": const.mu_tilde_e, \"p\": -const.mu_tilde_p, \"n\": 0},\n        \"5a\": {\"e\": 1, \"p\": -1, \"n\": 0},\n        \"5b\": {\"e\": 1, \"p\": -1, \"n\": 0},\n        \"6\": {\"e\": -const.mu_tilde_e, \"p\": const.mu_tilde_p, \"n\": 0},\n    }\n\n    coeff_func = {\n        \"1\": {\"e\": q_sq_on_mchi_sq, \"p\": q_sq_on_mchi_sq},\n        \"4\": {\"e\": q_sq_on_mchi_me, \"p\": q_sq_on_mchi_mp},\n        \"5a\": {\"e\": me_on_mchi, \"p\": mp_on_mchi},\n        \"5b\": {\"e\": me_on_mchi, \"p\": mp_on_mchi},\n        \"6\": {\"e\": me_on_mchi, \"p\": mp_on_mchi},\n    }\n\n    def reference_cross_section(m_chi: float) -&gt; float:\n        return (\n            np.pi\n            * (m_chi + const.m_e) ** 2\n            / (6 * m_chi**2 + const.m_e**2)\n            / const.m_e**2\n        )\n\n    return Model(\n        \"Magnetic Dipole\",\n        coeff_prefactor,\n        coeff_func,\n        ref_cross_sect=reference_cross_section,\n        shortname=\"mdm\",\n    )\n</code></pre>"},{"location":"reference/darkmagic/benchmark_models/utils/","title":"utils","text":""},{"location":"reference/darkmagic/materials/","title":"materials","text":""},{"location":"reference/darkmagic/materials/VBTS_Magnon/","title":"VBTS_Magnon","text":""},{"location":"reference/darkmagic/materials/YIG_Magnon/","title":"YIG_Magnon","text":""}]}