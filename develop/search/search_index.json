{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"DarkMAGIC","text":""},{"location":"#commands","title":"Commands","text":"<ul> <li><code>mkdocs new [dir-name]</code> - Create a new project.</li> <li><code>mkdocs serve</code> - Start the live-reloading docs server.</li> <li><code>mkdocs build</code> - Build the documentation site.</li> <li><code>mkdocs -h</code> - Print help message and exit.</li> </ul>"},{"location":"#project-layout","title":"Project layout","text":"<pre><code>mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.\n</code></pre>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>darkmagic<ul> <li>constants</li> <li>io</li> <li>material</li> <li>materials<ul> <li>VBTS_Magnon</li> <li>YIG_Magnon</li> </ul> </li> <li>model</li> <li>models<ul> <li>anapole</li> <li>magnetic_dipole</li> </ul> </li> <li>numerics</li> <li>parallel</li> <li>rate</li> <li>v_integrals</li> </ul> </li> </ul>"},{"location":"reference/darkmagic/","title":"darkmagic","text":""},{"location":"reference/darkmagic/constants/","title":"constants","text":"<p>Constants in natural units (unless otherwise specified).</p>"},{"location":"reference/darkmagic/io/","title":"io","text":""},{"location":"reference/darkmagic/io/#darkmagic.io.write_group_from_dict","title":"<code>write_group_from_dict(hdf5_file, group_name, data_dict)</code>","text":"<p>Recurses through a dictionary and creates appropriate groups or datasets This is parallel friendly, nothing is variable length.</p> Source code in <code>darkmagic/io.py</code> <pre><code>def write_group_from_dict(hdf5_file, group_name, data_dict):\n    \"\"\"\n    Recurses through a dictionary and creates appropriate groups or datasets\n    This is parallel friendly, nothing is variable length.\n    \"\"\"\n\n    for index in data_dict:\n        if isinstance(data_dict[index], dict):\n            write_group_from_dict(hdf5_file, f\"{group_name}/{index}\", data_dict[index])\n        else:\n            data = (\n                np.array([data_dict[index]], dtype=\"S\")\n                if isinstance(data_dict[index], str)\n                else data_dict[index]\n            )\n            hdf5_file.create_dataset(f\"{group_name}/{index}\", data=data)\n</code></pre>"},{"location":"reference/darkmagic/io/#darkmagic.io.write_hdf5","title":"<code>write_hdf5(out_file, material, model, numerics, masses, times, all_total_rate_list, all_diff_rate_list, all_binned_rate_list, comm=None)</code>","text":"<p>Write data to hdf5 file</p> <p>all_*_rate_list has a complicated format. For starters, it has as many elements as there are jobs. Each element is a list of the (m_chi, time) pairs that have been computed. Each of those elements is a two element array. The first element is a tuple of the mass and time index. The second element is either a scalar (total) or an array (binned and diff). For binned and diff, the dimensions of the array are num_bins and num_modes respectively.</p> <p>So for example, if we have 4 masses and 2 times, distributed over 4 jobs, then diff_rate list will look like this: [     # This is the job 1 array, which does mass index 0 at time indices 0,1     [ [ [0, 0], [num_bins elements]], [[0, 1], [num_bins_elements], ...], # job 1     # This is the job 1 array, which does mass index 1 at time indices 0,1     [ [ [1, 0], [num_bins elements]], [[1, 1], [num_bins_elements], ...], # job 2     ... ] This format is temporary, just for backwards compatibility with PhonoDark.</p> <p>Args: - out_file: Path to the output HDF5 file. - material: Material object. - model: Model object. - numerics: Numerics object. - masses: List of masses for the jobs. - times: List of times for the jobs. - all_total_rate_list: List of total rate data. - all_diff_rate_list: List of differential rate data. - all_binned_rate_list: List of binned rate data. - comm: MPI communicator for parallel writing (default is None).</p> <p>Returns: - None</p> Source code in <code>darkmagic/io.py</code> <pre><code>def write_hdf5(\n    out_file,\n    material,\n    model,\n    numerics,\n    masses,\n    times,\n    all_total_rate_list,\n    all_diff_rate_list,\n    all_binned_rate_list,\n    comm=None,\n):\n    \"\"\"\n\n    Write data to hdf5 file\n\n    all_*_rate_list has a complicated format.\n    For starters, it has as many elements as there are jobs. Each element is a list of the\n    (m_chi, time) pairs that have been computed. Each of those elements is a two element array.\n    The first element is a tuple of the mass and time index. The second element is either a scalar\n    (total) or an array (binned and diff). For binned and diff, the dimensions of the array are\n    num_bins and num_modes respectively.\n\n    So for example, if we have 4 masses and 2 times, distributed over 4 jobs, then diff_rate list will look like this:\n    [\n        # This is the job 1 array, which does mass index 0 at time indices 0,1\n        [ [ [0, 0], [num_bins elements]], [[0, 1], [num_bins_elements], ...], # job 1\n        # This is the job 1 array, which does mass index 1 at time indices 0,1\n        [ [ [1, 0], [num_bins elements]], [[1, 1], [num_bins_elements], ...], # job 2\n        ...\n    ]\n    This format is temporary, just for backwards compatibility with PhonoDark.\n\n    Args:\n    - out_file: Path to the output HDF5 file.\n    - material: Material object.\n    - model: Model object.\n    - numerics: Numerics object.\n    - masses: List of masses for the jobs.\n    - times: List of times for the jobs.\n    - all_total_rate_list: List of total rate data.\n    - all_diff_rate_list: List of differential rate data.\n    - all_binned_rate_list: List of binned rate data.\n    - comm: MPI communicator for parallel writing (default is None).\n\n    Returns:\n    - None\n    \"\"\"\n\n    def get_dicts(model, numerics, masses, times):\n        physics_parameters = {\n            # energy threshold\n            \"threshold\": 0,\n            # time of days (hr)\n            \"times\": times,\n            # - d log FDM / d log q. q dependence of mediator propagator\n            \"Fmed_power\": model.Fmed_power,\n            # power of q in the potential, used to find optimal integration mesh\n            \"power_V\": model.power_V,\n            # flag to compute for a specific model\n            # SI computes using the algorithm presented in 1910.08092\n            \"special_model\": False,\n            \"model_name\": \"mdm\",\n        }\n        dm_properties_dict = {\n            \"spin\": model.S_chi,\n            \"mass_list\": masses,\n        }\n        coeff = model.coeff\n        numerics_parameters = {\n            \"n_a\": numerics.N_grid[0],\n            \"n_b\": numerics.N_grid[1],\n            \"n_c\": numerics.N_grid[2],\n            \"power_a\": numerics.power_abc[0],\n            \"power_b\": numerics.power_abc[1],\n            \"power_c\": numerics.power_abc[2],\n            \"n_DW_x\": numerics.n_DW_xyz[0],\n            \"n_DW_y\": numerics.n_DW_xyz[1],\n            \"n_DW_z\": numerics.n_DW_xyz[2],\n            \"energy_bin_width\": numerics.bin_width,\n            \"q_cut\": numerics.use_q_cut,\n            \"special_mesh\": numerics.use_special_mesh,\n        }\n        return physics_parameters, dm_properties_dict, coeff, numerics_parameters\n\n    physics_parameters, dm_properties_dict, c_dict, numerics_parameters = get_dicts(\n        model, numerics, masses, times\n    )\n\n    # Get appropriate context manager for serial/parallel\n    if comm is None:\n        cm = h5py.File(out_file, \"w\")\n    else:\n        cm = h5py.File(out_file, \"w\", driver=\"mpio\", comm=comm)\n\n    with cm as out_f:\n        # Create groups/datasets and write out input parameters\n        write_group_from_dict(out_f, \"numerics\", numerics_parameters)\n        write_group_from_dict(out_f, \"particle_physics\", physics_parameters)\n        out_f.create_dataset(\"version\", data=np.array([\"0.0.1\"], dtype=\"S\"))\n        write_group_from_dict(\n            out_f, \"particle_physics/dm_properties\", dm_properties_dict\n        )\n        write_group_from_dict(out_f, \"particle_physics/c_coeffs\", c_dict)\n\n        num_bins = len(all_diff_rate_list[0][0][1])\n        num_modes = len(all_binned_rate_list[0][0][1])\n        # In parallel all datasets need to be created by all ranks\n        for i in range(len(physics_parameters[\"times\"])):\n            for j in range(len(dm_properties_dict[\"mass_list\"])):\n                out_f.create_dataset(f\"data/rate/{i}/{j}\", shape=(1,), dtype=\"f8\")\n                out_f.create_dataset(\n                    f\"data/diff_rate/{i}/{j}\", shape=(num_bins,), dtype=\"f8\"\n                )\n                out_f.create_dataset(\n                    f\"data/binned_rate/{i}/{j}\", shape=(num_modes,), dtype=\"f8\"\n                )\n        # Write out rates to the file\n        # To accomodate for serial, can flatten all_total_rate_list\n        for tr_list, br_list, dr_list in zip(\n            all_total_rate_list, all_binned_rate_list, all_diff_rate_list\n        ):\n            for t, b, d in zip(tr_list, br_list, dr_list):\n                # The first element of t, b, and d is a tuple of the mass and time index\n                # The second element is either a scalar (total) or an array (binned and diff)\n                # For binned and diff, the dimensions of the array are num_bins and num_modes\n                # respectively\n\n                # mass_index, time_index\n                j, i = map(str, map(int, t[0]))\n                # print(f'Writing data/rate/{i}/{j} = {t[1]} to {out_f[\"data\"][\"rate\"][i][j]}')\n                out_f[\"data\"][\"rate\"][i][j][...] = t[1]\n                out_f[\"data\"][\"binned_rate\"][i][j][...] = b[1]\n                out_f[\"data\"][\"diff_rate\"][i][j][...] = d[1]\n</code></pre>"},{"location":"reference/darkmagic/material/","title":"material","text":""},{"location":"reference/darkmagic/material/#darkmagic.material.MaterialProperties","title":"<code>MaterialProperties(N=None, S=None, L=None, L_dot_S=None, L_tens_S=None, lambda_S=None, lambda_L=None, m_psi=None)</code>","text":"<p>Class for DM-relevant material properties, such as the number of fermions, spin, orbital angular momentum, etc.</p> <p>Attributes:</p> Name Type Description <code>N</code> <code>dict</code> <p>Fermion numbers.</p> <code>S</code> <code>dict</code> <p>Spin vectors.</p> <code>L</code> <code>dict</code> <p>Orbital angular momentum vectors.</p> <code>L_dot_S</code> <code>dict</code> <p>\\(L \\cdot S\\)</p> <code>L_tens_S</code> <code>dict</code> <p>Spin orbit coupling tensor \\(L \\otimes S\\)</p> <code>lambda_S</code> <code>ArrayLike</code> <p>spin-coefficient for magnons</p> <code>lambda_L</code> <code>ArrayLike</code> <p>orbital angular mom.-coefficient for magnons</p> <code>m_psi</code> <code>dict</code> <p>Dictionary of masses for different particles.</p> <p>Methods:</p> Name Description <code>validate_for_phonons</code> <p>Validates that the material properties are suitable for phonon calculations.</p> <code>validate_for_magnons</code> <p>Validates that the material properties are suitable for magnon calculations.</p> <p>Parameters:</p> Name Type Description Default <code>N</code> <code>dict</code> <p>Fermion numbers.</p> <code>None</code> <code>S</code> <code>dict</code> <p>Spin vectors.</p> <code>None</code> <code>L</code> <code>dict</code> <p>Orbital angular momentum vectors.</p> <code>None</code> <code>L_dot_S</code> <code>dict</code> <p>\\(L \\cdot S\\)</p> <code>None</code> <code>L_tens_S</code> <code>dict</code> <p>Spin orbit coupling tensor \\(L \\otimes S\\)</p> <code>None</code> <code>lambda_S</code> <code>ArrayLike</code> <p>spin-coefficient for magnons</p> <code>None</code> <code>lambda_L</code> <code>ArrayLike</code> <p>orbital angular mom.-coefficient for magnons</p> <code>None</code> <code>m_psi</code> <code>dict</code> <p>Masses of the fermions. Defaults to NIST values.</p> <code>None</code> Source code in <code>darkmagic/material.py</code> <pre><code>def __init__(\n    self,\n    N: dict = None,\n    S: dict = None,\n    L: dict = None,\n    L_dot_S: dict = None,\n    L_tens_S: dict = None,\n    lambda_S: ArrayLike = None,\n    lambda_L: ArrayLike = None,\n    m_psi: dict = None,\n):\n    r\"\"\"\n    Material properties constructor. All dicts have keys \"n\", \"p\", \"e\" for neutron, proton and electron. Any missing values are instantiated to 0.\n\n    Args:\n        N (dict, optional): Fermion numbers.\n        S (dict, optional): Spin vectors.\n        L (dict, optional): Orbital angular momentum vectors.\n        L_dot_S (dict, optional): $L \\cdot S$\n        L_tens_S (dict, optional): Spin orbit coupling tensor $L \\otimes S$\n        lambda_S (ArrayLike, optional): spin-coefficient for magnons\n        lambda_L (ArrayLike, optional): orbital angular mom.-coefficient for magnons\n        m_psi (dict, optional): Masses of the fermions. Defaults to NIST values.\n    \"\"\"\n    # Phonons\n    self.N = N\n    self.S = S\n    self.L = L\n    self.L_dot_S = L_dot_S\n    self.L_tens_S = L_tens_S\n    # Magnons\n    self.lambda_S = lambda_S\n    self.lambda_L = lambda_L\n    # Mass of the particles\n    self.m_psi = m_psi\n</code></pre>"},{"location":"reference/darkmagic/material/#darkmagic.material.MaterialProperties.validate_for_phonons","title":"<code>validate_for_phonons(n_atoms)</code>","text":"<p>Validates that the material properties are suitable for phonons. Namely, at least one of N, S, L, L_dot_S or L_tens_S must be defined.</p> <p>Parameters:</p> Name Type Description Default <code>n_atoms</code> <code>int</code> <p>Number of atoms in the material.</p> required <p>Raises:</p> Type Description <code>AssertionError</code> <p>If any of the required material properties for phonons are missing or have incorrect dimensions.</p> Source code in <code>darkmagic/material.py</code> <pre><code>def validate_for_phonons(self, n_atoms: int) -&gt; None:\n    \"\"\"\n    Validates that the material properties are suitable for phonons.\n    Namely, at least one of N, S, L, L_dot_S or L_tens_S must be defined.\n\n    Args:\n        n_atoms (int): Number of atoms in the material.\n\n    Raises:\n        AssertionError: If any of the required material properties for phonons are missing or have incorrect dimensions.\n\n    \"\"\"\n    assert any([self.N, self.S, self.L, self.L_dot_S, self.L_tens_S])\n    for d in [self.N, self.S, self.L, self.L_dot_S, self.L_tens_S]:\n        if d:\n            assert any(np.any(v) for v in d.values())\n\n    self._validate_input(n_atoms)\n</code></pre>"},{"location":"reference/darkmagic/material/#darkmagic.material.MaterialProperties.validate_for_magnons","title":"<code>validate_for_magnons(n_atoms)</code>","text":"<p>Validates that the material properties are suitable for magnons. Namely, at least one of lambda_S and lambda_L must be defined.</p> <p>Parameters:</p> Name Type Description Default <code>n_atoms</code> <code>int</code> <p>Number of atoms in the material.</p> required <p>Raises:</p> Type Description <code>AssertionError</code> <p>If any of the required material properties for magnons are missing or have incorrect dimensions.</p> Source code in <code>darkmagic/material.py</code> <pre><code>def validate_for_magnons(self, n_atoms: int) -&gt; None:\n    \"\"\"\n    Validates that the material properties are suitable for magnons. Namely, at least one of lambda_S and lambda_L must be defined.\n\n    Args:\n        n_atoms (int): Number of atoms in the material.\n\n    Raises:\n        AssertionError: If any of the required material properties for magnons are missing or have incorrect dimensions.\n\n    \"\"\"\n    assert any([np.any(self.lambda_S), np.any(self.lambda_L)])\n    # TODO: not nice to have so many return values\n    self._validate_input(n_atoms)\n</code></pre>"},{"location":"reference/darkmagic/material/#darkmagic.material.Material","title":"<code>Material(name, properties, structure, m_atoms)</code>","text":"<p>Represents a generic material with its structural and atomic properties.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>The name of the material.</p> <code>properties</code> <code>MaterialProperties</code> <p>The properties of the material.</p> <code>real_frac_to_cart</code> <code>ndarray</code> <p>The transformation matrix from fractional to Cartesian coordinates (units 1/eV), in real space.</p> <code>real_cart_to_frac</code> <code>ndarray</code> <p>The transformation matrix from Cartesian (units 1/eV) to fractional coordinates, in real space.</p> <code>recip_frac_to_cart</code> <code>ndarray</code> <p>The transformation matrix from fractional to Cartesian coordinates (units eV), in k-space.</p> <code>recip_cart_to_frac</code> <code>ndarray</code> <p>The transformation matrix from Cartesian (units eV) to fractional coordinates, in k-space.</p> <code>m_atoms</code> <code>ArrayLike</code> <p>an array of atomic masses, in eV.</p> <code>m_cell</code> <code>ndarray</code> <p>The total mass of the atoms in the material, in eV.</p> <code>xj</code> <code>ndarray</code> <p>The Cartesian coordinates (units 1/eV) of the atoms in the material.</p> <code>structure</code> <code>Structure</code> <p>the crystal structure <code>pymatgen</code> <code>Structure</code> object.</p> <code>n_atoms</code> <code>int</code> <p>The number of atoms in the material.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the material.</p> required <code>properties</code> <code>MaterialProperties</code> <p>The properties of the material.</p> required <code>structure</code> <code>Structure</code> <p>The structure of the material.</p> required <code>m_atoms</code> <code>ArrayLike</code> <p>atomic masses in eV.</p> required Source code in <code>darkmagic/material.py</code> <pre><code>def __init__(\n    self,\n    name: str,\n    properties: MaterialProperties,\n    structure: Structure,\n    m_atoms: ArrayLike,\n):\n    \"\"\"\n    Constructor for a generic Material object\n\n    Args:\n        name (str): The name of the material.\n        properties (MaterialProperties): The properties of the material.\n        structure (Structure): The structure of the material.\n        m_atoms (ArrayLike): atomic masses in eV.\n    \"\"\"\n    # Material properties\n    self.name = name\n    self.properties = properties\n\n    # Define transformation matrices\n    self.real_frac_to_cart = structure.lattice.matrix.T\n    self.real_cart_to_frac = LA.inv(self.real_frac_to_cart)\n    self.recip_frac_to_cart = structure.lattice.reciprocal_lattice.matrix.T\n    self.recip_cart_to_frac = LA.inv(self.recip_frac_to_cart)\n\n    # Atomic and structural properties\n    self.m_atoms = m_atoms\n    self.m_cell = np.sum(m_atoms)\n    self.xj = structure.cart_coords\n    self.structure = structure\n    self.n_atoms = len(structure.species)\n\n    # Internal variables\n    self._max_dE = None\n    self._q_cut = None\n</code></pre>"},{"location":"reference/darkmagic/material/#darkmagic.material.PhononMaterial","title":"<code>PhononMaterial(name, properties, phonopy_yaml_path)</code>","text":"<p>             Bases: <code>Material</code></p> <p>A class for materials with phonons.</p> <p>Attributes:</p> Name Type Description <code>phonopy_file</code> <code>Phonopy</code> <p>The Phonopy object for the material's phonons</p> <code>n_modes</code> <code>int</code> <p>The number of phonon modes in the material.</p> <code>born</code> <code>ndarray</code> <p>The born effective charges</p> <code>epsilon</code> <code>ndarray</code> <p>The dielectric tensor</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the material.</p> required <code>properties</code> <code>MaterialProperties</code> <p>The properties of the material.</p> required <code>phonopy_yaml_path</code> <code>str</code> <p>The path to the Phonopy YAML file.</p> required Source code in <code>darkmagic/material.py</code> <pre><code>def __init__(\n    self, name: str, properties: MaterialProperties, phonopy_yaml_path: str\n):\n    \"\"\"\n    Constructor for PhononMaterial objects.\n\n    Args:\n        name (str): The name of the material.\n        properties (MaterialProperties): The properties of the material.\n        phonopy_yaml_path (str): The path to the Phonopy YAML file.\n\n    \"\"\"\n    # TODO: Need a check for when phonopy_yaml does not have NAC\n    phonopy_file = phonopy.load(phonopy_yaml=phonopy_yaml_path, is_nac=True)\n    self.phonopy_file = phonopy_file\n    n_atoms = phonopy_file.primitive.get_number_of_atoms()\n    self.n_modes = 3 * n_atoms\n\n    properties.validate_for_phonons(n_atoms)\n\n    m_atoms = phonopy_file.primitive.masses * const.amu_to_eV\n\n    # NAC parameters (born effective charges and dielectric tensor)\n    self.born = np.array(\n        phonopy_file.nac_params.get(\"born\", np.zeros((n_atoms, 3, 3)))\n    )\n    self.epsilon = np.array(\n        phonopy_file.nac_params.get(\"dielectric\", np.identity(3))\n    )\n\n    # Create a Structure object\n    # At some point should make careful assessment of primitive vs unit_cell\n    # PhonoDark uses primitive, but what about when it's different from unit_cell?\n    positions = phonopy_file.primitive.scaled_positions\n    lattice = np.array(phonopy_file.primitive.cell) * const.Ang_to_inveV\n    species = phonopy_file.primitive.symbols\n\n    structure = Structure(lattice, species, positions)\n\n    super().__init__(name, properties, structure, m_atoms)\n</code></pre>"},{"location":"reference/darkmagic/material/#darkmagic.material.PhononMaterial.max_dE","title":"<code>max_dE: float</code>  <code>property</code>","text":"<p>Returns omega_ph_max = max(omega_ph) if there are optical modes, otherwise returns the average over the entire Brillouin zone. The quantities are obviously not the same but should be the same order. See theoretical framework paper, paragraph in middle of page 24 (of published version).</p> <p>TODO: clarify this</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>the maximum energy deposition</p>"},{"location":"reference/darkmagic/material/#darkmagic.material.PhononMaterial.q_cut","title":"<code>q_cut: float</code>  <code>property</code>","text":"<p>The Debye-Waller factor suppresses the rate at larger q beyond q ~ np.sqrt(m_atom * omega_ph). This method calculates an estimate for the cutoff value of q.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The cutoff value of q.</p>"},{"location":"reference/darkmagic/material/#darkmagic.material.PhononMaterial.get_eig","title":"<code>get_eig(k_points, with_eigenvectors=True)</code>","text":"<p>Calculates the phonon frequencies and eigenvectors for the given k-points.</p> <p>Parameters:</p> Name Type Description Default <code>k_points</code> <code>ArrayLike</code> <p>Numpy array of k-points in fractional coordinates.</p> required <code>with_eigenvectors</code> <code>bool</code> <p>Flag indicating whether to calculate eigenvectors.</p> <code>True</code> <p>Returns:</p> Type Description <code>Tuple[ndarray, ndarray]</code> <p>A tuple containing the phonon frequencies and eigenvectors.</p> <ul> <li> <p>The phonon frequencies are represented as a numpy array of shape (n_k,n_modes)</p> </li> <li> <p>The eigenvectors are represented as a numpy array of shape (n_k, n_modes, n_atoms, 3)</p> </li> </ul> <p>where n_k is the number of k-points, n_modes is the number of modes, n_atoms is the number of atoms, and the last index is for the x, y, z components of the eigenvectors.</p> Source code in <code>darkmagic/material.py</code> <pre><code>def get_eig(\n    self, k_points: ArrayLike, with_eigenvectors: bool = True\n) -&gt; Tuple[np.ndarray, np.ndarray]:\n    \"\"\"\n    Calculates the phonon frequencies and eigenvectors for the given k-points.\n\n    Args:\n        k_points (ArrayLike): Numpy array of k-points in fractional coordinates.\n        with_eigenvectors (bool, optional): Flag indicating whether to calculate eigenvectors.\n\n    Returns:\n        A tuple containing the phonon frequencies and eigenvectors.\n\n            * The phonon frequencies are represented as a numpy array of shape (n_k,n_modes)\n\n            * The eigenvectors are represented as a numpy array of shape (n_k, n_modes, n_atoms, 3)\n\n            where n_k is the number of k-points, n_modes is the number of modes,\n            n_atoms is the number of atoms, and the last index is\n            for the x, y, z components of the eigenvectors.\n\n    Raises:\n        None\n\n    \"\"\"\n    # run phonopy in mesh mode\n    self.phonopy_file.run_qpoints(k_points, with_eigenvectors=with_eigenvectors)\n\n    mesh_dict = self.phonopy_file.get_qpoints_dict()\n\n    eigenvectors_pre = mesh_dict.get(\"eigenvectors\", None)\n    # print(eigenvectors_pre)\n    # convert frequencies to correct units\n    omega = const.THz_to_eV * mesh_dict[\"frequencies\"]\n\n    eigenvectors = np.zeros(\n        (len(k_points), self.n_modes, self.n_atoms, 3), dtype=complex\n    )\n    # Need to reshape the eigenvectors from (n_k, n_modes, n_modes)\n    # to (n_k, n_atoms, n_modes, 3) # TODO: is this correct?\n    if with_eigenvectors:\n        # TODO: Should rewrite this with a reshape...\n        for q in range(len(k_points)):\n            for nu in range(self.n_modes):\n                eigenvectors[q, nu] = np.array_split(\n                    eigenvectors_pre[q].T[nu], self.n_atoms\n                )\n\n    return omega, eigenvectors\n</code></pre>"},{"location":"reference/darkmagic/material/#darkmagic.material.MagnonMaterial","title":"<code>MagnonMaterial(name, properties, hamiltonian, m_cell, nodmi=False, noaniso=False)</code>","text":"<p>             Bases: <code>Material</code></p> <p>A class for materials with magnons</p> <p>Attributes:</p> Name Type Description <code>hamiltonian</code> <code>SpinHamiltonian</code> <p>The spin Hamiltonian of the material.</p> <code>n_modes</code> <code>int</code> <p>The number of magnon modes.</p> <code>dispersion</code> <code>MagnonDispersion</code> <p>The magnon dispersion.</p> <p>In the current implementation, the hamiltonian only contains the magnetic atoms and their interactions. So m_cell needs to be specified separately</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the material.</p> required <code>properties</code> <code>MaterialProperties</code> <p>The properties of the material.</p> required <code>hamiltonian</code> <code>SpinHamiltonian</code> <p>The spin Hamiltonian</p> required <code>m_cell</code> <code>float</code> <p>the total mass of all ions in the cell</p> required <code>nodmi</code> <p>Whether to include DM interactions.</p> <code>False</code> <code>noaniso</code> <p>Whether to include anisotropic exchange.</p> <code>False</code> Source code in <code>darkmagic/material.py</code> <pre><code>def __init__(\n    self,\n    name: str,\n    properties: MaterialProperties,\n    hamiltonian: SpinHamiltonian,\n    m_cell: float,\n    nodmi=False,\n    noaniso=False,\n):\n    \"\"\"\n    Constructor for a magnon material\n\n    In the current implementation, the hamiltonian only\n    contains the magnetic atoms and their interactions.\n    So m_cell needs to be specified separately\n\n    Args:\n        name: The name of the material.\n        properties: The properties of the material.\n        hamiltonian: The spin Hamiltonian\n        m_cell: the total mass of all ions in the cell\n        nodmi: Whether to include DM interactions.\n        noaniso: Whether to include anisotropic exchange.\n    \"\"\"\n    # Ensure the hamiltonian is in the correct units\n    # hamiltonian.cell *= const.Ang_to_inveV\n    # In the future we should have a check that it comes in in units of A\n    # And convert it here\n    self.hamiltonian = hamiltonian\n    n_atoms = len(hamiltonian.magnetic_atoms)\n    self.n_modes = n_atoms\n    self.dispersion = MagnonDispersion(\n        hamiltonian, phase_convention=\"tanner\", nodmi=nodmi, noaniso=noaniso\n    )\n\n    n_atoms = len(hamiltonian.magnetic_atoms)  # Number of magnetic atoms\n    properties.validate_for_magnons(n_atoms)\n    # Atom positions in cartesian coordinates (units of 1/eV)\n    self.xj = np.array(\n        [\n            hamiltonian.get_atom_coordinates(atom, relative=False)\n            for atom in hamiltonian.magnetic_atoms\n        ]\n    )\n    # sqrt(Sj/2)\n    # TODO: make this an internal variable\n    self.sqrt_spins_2 = np.sqrt(\n        np.array([atom.spin for atom in hamiltonian.magnetic_atoms]) / 2\n    )\n    # The vectors for rotating to local coordiante system\n    # TODO: make this an internal variable\n    self.rj = self.dispersion.u\n\n    positions = np.array([a.position for a in hamiltonian.magnetic_atoms])\n    lattice = hamiltonian.cell\n    species = [a.type for a in hamiltonian.magnetic_atoms]\n    structure = Structure(lattice, species, positions)\n\n    m_atoms = [m_cell / n_atoms] * n_atoms\n    super().__init__(name, properties, structure, m_atoms)\n</code></pre>"},{"location":"reference/darkmagic/material/#darkmagic.material.MagnonMaterial.max_dE","title":"<code>max_dE: float</code>  <code>property</code>","text":"<p>TODO: this needs improvement</p> <p>Returns the maximum dE possible for the material. For magnons, we estimate this as roughly 3 times the highest magnon frequency at the Brillouin zone (BZ) boundary. If there are no gapped modes at the gamma point, the maximum dE will be 0.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The maximum dE value.</p> Notes <p>This calculation should be an average over the Brillouin zone (BZ).</p>"},{"location":"reference/darkmagic/material/#darkmagic.material.MagnonMaterial.q_cut","title":"<code>q_cut: float</code>  <code>property</code>","text":"<p>For magnons there is no <code>q_cut</code>, so we just set this to a very large number.</p> <p>Returns:</p> Name Type Description <code>q_cut</code> <code>float</code> <p>a very large number.</p>"},{"location":"reference/darkmagic/material/#darkmagic.material.MagnonMaterial.get_eig","title":"<code>get_eig(k, G)</code>","text":"<p>Calculate the eigenvalues and magnon polarization vectors for a given k-point and G-vector.</p> <p>Parameters:</p> Name Type Description Default <code>k</code> <code>ArrayLike</code> <p>Single k-point, cartesian coordinates (units of eV).</p> required <code>G</code> <code>ArrayLike</code> <p>Single G-vector, cartesian coordinates (units of eV).</p> required <p>Returns:</p> Type Description <code>Tuple[ndarray, ndarray]</code> <p>Tuple[np.ndarray, np.ndarray]: A tuple containing the eigenvalues (omega_nu_k) and eigenvectors (epsilon_nu_k_G). - omega_nu_k: (N,) an array of complex numbers representing the eigenvalues in eV. - epsilon_nu_k_G: (N,3) array of complex numbers representing the eigenvectors (magnon polarization vectors) in eV/?? N is the number of magnon modes.</p> Source code in <code>darkmagic/material.py</code> <pre><code>def get_eig(self, k: ArrayLike, G: ArrayLike) -&gt; Tuple[np.ndarray, np.ndarray]:\n    \"\"\"\n    Calculate the eigenvalues and magnon polarization vectors for a given k-point and G-vector.\n\n    Args:\n        k (ArrayLike): Single k-point, cartesian coordinates (units of eV).\n        G (ArrayLike): Single G-vector, cartesian coordinates (units of eV).\n\n    Returns:\n        Tuple[np.ndarray, np.ndarray]: A tuple containing the eigenvalues (omega_nu_k) and eigenvectors (epsilon_nu_k_G).\n            - omega_nu_k: (N,) an array of complex numbers representing the eigenvalues in eV.\n            - epsilon_nu_k_G: (N,3) array of complex numbers representing the eigenvectors (magnon polarization vectors) in eV/??\n            N is the number of magnon modes.\n\n    \"\"\"\n    # Calculate the prefactor\n    prefactor = self.sqrt_spins_2 * np.exp(1j * np.dot(self.xj, G))\n\n    # See Tanner's Disseration and RadTools doc for explanation of the 1/2\n    N = self.n_atoms\n    omega_nu_k, Tk = self._get_omega_T(self.dispersion.h(k) / 2)\n    Uk_conj = np.conjugate(Tk[:N, :N])  # This is U_{j,nu,k})*\n    V_minusk = np.conjugate(Tk[N:, :N])  # This is ((V_{j,nu,-k})*)*\n\n    epsilon_nu_k_G = (prefactor[:, None] * V_minusk).T @ np.conjugate(self.rj) + (\n        prefactor[:, None] * Uk_conj\n    ).T @ self.rj\n\n    return omega_nu_k, epsilon_nu_k_G  # (n,) and (n,3) array of complex numbers\n</code></pre>"},{"location":"reference/darkmagic/model/","title":"model","text":""},{"location":"reference/darkmagic/model/#darkmagic.model.Model","title":"<code>Model(name, coeff, coeff_qmS, Fmed_power=0, power_V=0, S_chi=0.5)</code>","text":"<p>power_V: float, power of q in the V term (for special mesh) s_chi float, spin of DM particle</p> Source code in <code>darkmagic/model.py</code> <pre><code>def __init__(\n    self,\n    name: str,\n    coeff: dict,\n    coeff_qmS: dict,\n    Fmed_power: int = 0,\n    power_V: int = 0,\n    S_chi: float = 0.5,\n):\n    \"\"\"\n    name: string\n    Fmed_power: float, negative power of q in the Fmed term\n    power_V: float, power of q in the V term (for special mesh)\n    s_chi float, spin of DM particle\n    \"\"\"\n    self.name = name\n\n    self.Fmed_power = Fmed_power\n    self.power_V = power_V\n    self.S_chi = S_chi\n    self.coeff = coeff\n    self.coeff_qmS = coeff_qmS  # Needs better name\n    self.operators, self.particles = self.get_operators_and_fermions(coeff)\n</code></pre>"},{"location":"reference/darkmagic/model/#darkmagic.model.Model.screen_coeff","title":"<code>screen_coeff(q, m_chi, epsilon)</code>","text":"<p>Screen the coefficients by the form factor</p> Source code in <code>darkmagic/model.py</code> <pre><code>def screen_coeff(self, q, m_chi, epsilon):\n    \"\"\"\n    Screen the coefficients by the form factor\n    \"\"\"\n    q2_qepsq = np.linalg.norm(q, axis=1) ** 2 / np.einsum(\n        \"ij,jk,ik-&gt;i\", q, epsilon, q\n    )\n    screened_coeff_qmS = {alpha: {} for alpha in self.operators}\n    for alpha, c_alpha in self.coeff.items():\n        screened_c = {\n            \"e\": q2_qepsq * c_alpha.get(\"e\", 0),\n            \"n\": c_alpha.get(\"n\", 0),\n            \"p\": c_alpha.get(\"p\", 0) + (1 - q2_qepsq) * c_alpha.get(\"e\", 0),\n        }\n        for psi in c_alpha.keys():\n            screened_coeff_qmS[alpha][psi] = screened_c[psi] * self.coeff_qmS(\n                alpha, psi, q, m_chi, self.S_chi\n            )\n</code></pre>"},{"location":"reference/darkmagic/model/#darkmagic.model.Model.get_operators_and_fermions","title":"<code>get_operators_and_fermions(coeff)</code>  <code>staticmethod</code>","text":"<p>Gets the non-zero operators and particles (psi) from the c_dict</p> Source code in <code>darkmagic/model.py</code> <pre><code>@staticmethod\ndef get_operators_and_fermions(coeff):\n    \"\"\"\n    Gets the non-zero operators and particles (psi) from the c_dict\n    \"\"\"\n\n    nonzero_pairs = [\n        (alpha, psi)\n        for alpha, c_alpha in coeff.items()\n        for psi, c_psi in c_alpha.items()\n        if c_psi != 0\n    ]\n    return {pair[0] for pair in nonzero_pairs}, {pair[1] for pair in nonzero_pairs}\n</code></pre>"},{"location":"reference/darkmagic/numerics/","title":"numerics","text":""},{"location":"reference/darkmagic/numerics/#darkmagic.numerics.Grid","title":"<code>Grid(m_chi, v_e, numerics, material)</code>","text":"Source code in <code>darkmagic/numerics.py</code> <pre><code>def __init__(self, m_chi, v_e, numerics, material):\n    # Get q and G vectors\n    q_cut = material.q_cut if numerics.use_q_cut else 1e10\n    self.q_max = min(2 * m_chi * (const.VESC + const.VE), q_cut)\n    self.q_cart, self.q_frac = self._get_q_points(\n        numerics.N_grid, m_chi, v_e, material.recip_cart_to_frac\n    )\n    # These show up in many so it's efficient to compute them only once\n    self.q_norm = LA.norm(self.q_cart, axis=1)\n    self.q_hat = self.q_cart / self.q_norm[:, None]\n\n    # Get G-vectors\n    self.G_cart, self.G_frac = self._get_G_vectors(material.recip_frac_to_cart)\n    # Deriving this is straightforward, remember we're sampling\n    # with a power of 2 in the q direction, hence the square roots on |q|\n    self.jacobian = 8 * np.pi * self.q_norm ** (5 / 2) * self.q_max ** (1 / 2)\n\n    # Get the k-vectors\n    self.k_frac = self.q_frac - self.G_frac\n    self.k_cart = np.matmul(self.k_frac, material.recip_frac_to_cart)\n</code></pre>"},{"location":"reference/darkmagic/parallel/","title":"parallel","text":""},{"location":"reference/darkmagic/parallel/#darkmagic.parallel.distribute_load","title":"<code>distribute_load(n_proc, masses, times)</code>","text":"<p>This function distributes the load of jobs across the available processors. It attempts to balance the load as much as possible.</p> Source code in <code>darkmagic/parallel.py</code> <pre><code>def distribute_load(n_proc, masses, times):\n    \"\"\"\n    This function distributes the load of jobs across the available processors.\n    It attempts to balance the load as much as possible.\n    \"\"\"\n    # TODO: change to logging\n    print(\"Distributing load among processors.\")\n    # Our jobs list is a list of tuples, where each tuple is a pair of (mass, time) indices\n    total_job_list = np.array(\n        list(itertools.product(range(len(masses)), range(len(times))))\n    )\n    n_jobs = len(total_job_list)\n\n    base_jobs_per_proc = n_jobs // n_proc  # each processor has at least this many jobs\n    extra_jobs = 1 if n_jobs % n_proc else 0  # might need 1 more job on some processors\n    # Note a fan of using a sentinel value to indicate a \"do nothing\" job\n    job_list = JOB_SENTINEL * np.ones(\n        (n_proc, base_jobs_per_proc + extra_jobs, 2), dtype=int\n    )\n\n    for i in range(n_jobs):\n        proc_index = i % n_proc\n        job_index = i // n_proc\n        job_list[proc_index, job_index] = total_job_list[i]\n\n    if n_jobs &gt; n_proc:\n        print(\"Number of jobs exceeds the number of processors.\")\n        print(f\"Baseline number of jobs per processor: {str(base_jobs_per_proc)}\")\n        print(\n            \"Remaining processors with one extra job: \"\n            + str(n_jobs - n_proc * base_jobs_per_proc)\n        )\n    elif n_jobs &lt; n_proc:\n        print(\"Number of jobs is fewer than the number of processors.\")\n        print(\"Consider reducing the number of processors for more efficiency.\")\n        print(f\"Total number of jobs: {n_jobs}\")\n    else:\n        print(\"Number of jobs matches the number of processors. Maximally parallized.\")\n\n    return job_list\n</code></pre>"},{"location":"reference/darkmagic/rate/","title":"rate","text":""},{"location":"reference/darkmagic/rate/#darkmagic.rate.Calculation","title":"<code>Calculation(m_chi, material, model, numerics, time=0, v_e=None)</code>","text":"<p>Generic class for calculating the differential rate</p> Source code in <code>darkmagic/rate.py</code> <pre><code>def __init__(\n    self,\n    m_chi: float,\n    material: MagnonMaterial,\n    model: Model,\n    numerics: Numerics,\n    time: float | None = 0,\n    v_e: ArrayLike | None = None,\n):\n    self.m_chi = m_chi\n    if time is None and v_e is None:\n        raise ValueError(\"Either time or v_e must be provided\")\n    if time is not None and v_e is not None:\n        raise ValueError(\"Only one of time or v_e should be provided\")\n    self.v_e = self.compute_ve(time) if time is not None else v_e\n    self.material = material\n    self.model = model\n    self.numerics = numerics\n    self.grid = numerics.get_grid(m_chi, self.v_e, material)\n</code></pre>"},{"location":"reference/darkmagic/rate/#darkmagic.rate.Calculation.compute_ve","title":"<code>compute_ve(t)</code>","text":"<p>Returns the earth's velocity in the lab frame at time t (in hours)</p> Source code in <code>darkmagic/rate.py</code> <pre><code>def compute_ve(self, t: float):\n    \"\"\"\n    Returns the earth's velocity in the lab frame at time t (in hours)\n    \"\"\"\n    phi = 2 * np.pi * (t / 24.0)\n    theta = const.theta_earth\n\n    return const.VE * np.array(\n        [\n            np.sin(theta) * np.sin(phi),\n            np.cos(theta) * np.sin(theta) * (np.cos(phi) - 1),\n            (np.sin(theta) ** 2) * np.cos(phi) + np.cos(theta) ** 2,\n        ]\n    )\n</code></pre>"},{"location":"reference/darkmagic/rate/#darkmagic.rate.MagnonCalculation","title":"<code>MagnonCalculation(m_chi, material, model, numerics, time=0, v_e=None)</code>","text":"<p>             Bases: <code>Calculation</code></p> <p>Class for calculating the differential rate for magnon scattering</p> Source code in <code>darkmagic/rate.py</code> <pre><code>def __init__(\n    self,\n    m_chi: float,\n    material: MagnonMaterial,\n    model: Model,\n    numerics: Numerics,\n    time: float | None = 0,\n    v_e: ArrayLike | None = None,\n):\n    self.m_chi = m_chi\n    if time is None and v_e is None:\n        raise ValueError(\"Either time or v_e must be provided\")\n    if time is not None and v_e is not None:\n        raise ValueError(\"Only one of time or v_e should be provided\")\n    self.v_e = self.compute_ve(time) if time is not None else v_e\n    self.material = material\n    self.model = model\n    self.numerics = numerics\n    self.grid = numerics.get_grid(m_chi, self.v_e, material)\n</code></pre>"},{"location":"reference/darkmagic/rate/#darkmagic.rate.MagnonCalculation.calculate_rate","title":"<code>calculate_rate()</code>","text":"<p>Computes the differential rate</p> Source code in <code>darkmagic/rate.py</code> <pre><code>def calculate_rate(\n    self,\n):\n    \"\"\"\n    Computes the differential rate\n    \"\"\"\n\n    max_bin_num = math.ceil(self.material.max_dE / self.numerics.bin_width)\n\n    n_modes = self.material.n_modes\n    n_q = len(self.grid.q_cart)\n\n    diff_rate = np.zeros(max_bin_num, dtype=complex)\n    binned_rate = np.zeros(n_modes, dtype=complex)\n    omegas = np.zeros((n_q, n_modes))\n    epsilons = np.zeros((n_q, n_modes, 3), dtype=complex)\n\n    model_name = self.model.name\n\n    # TODO: implement this without a loop?\n    for iq, (G, k) in enumerate(zip(self.grid.G_cart, self.grid.k_cart)):\n        if iq % 1000 == 0:\n            print(f\"* m_chi = {self.m_chi:13.4f}, q-point: {iq:6d}/{n_q:6d})\")\n        omegas[iq, :], epsilons[iq, :, :] = self.material.get_eig(k, G)\n\n    v_dist = MBDistribution(self.grid, omegas, self.m_chi, self.v_e)\n\n    # Along with omega and epsilons, these are all q*nu arrays\n    bin_num = np.floor((omegas) / self.numerics.bin_width).astype(int)\n    g0 = v_dist.g0\n\n    if model_name == \"mdm\":\n        sigma_nu_q = self.sigma_mdm(self.grid.q_cart, epsilons)\n    elif model_name == \"ap\":\n        sigma_nu_q = self.sigma_ap(self.grid.q_cart, epsilons)\n    tiled_jacobian = np.tile(self.grid.jacobian, (n_modes, 1)).T\n\n    # Integrate to get deltaR\n    vol_element = tiled_jacobian * (\n        (2 * np.pi) ** 3 * np.prod(self.numerics.N_grid)\n    ) ** (-1)\n    deltaR = (\n        (1 / self.material.m_cell)\n        * (const.rho_chi / self.m_chi)\n        * vol_element\n        * sigma_nu_q\n        * g0\n    )\n\n    # Get diff rate, binned rate and total rate\n    diff_rate = np.zeros(max_bin_num)\n    np.add.at(diff_rate, bin_num, deltaR)\n    binned_rate = np.sum(deltaR, axis=0)\n    total_rate = sum(diff_rate)\n\n    return [diff_rate, binned_rate, total_rate]\n</code></pre>"},{"location":"reference/darkmagic/v_integrals/","title":"v_integrals","text":""},{"location":"reference/darkmagic/v_integrals/#darkmagic.v_integrals.MBDistribution","title":"<code>MBDistribution(grid, omega, m_chi, v_e)</code>","text":"<p>Class for truncated Maxwell-Boltzmann distribution</p> Source code in <code>darkmagic/v_integrals.py</code> <pre><code>def __init__(self, grid, omega, m_chi, v_e) -&gt; None:\n    self.grid = grid\n    self.omega = omega\n    self.m_chi = m_chi\n    self.v_e = np.array(v_e)\n\n    # Internal variables\n    self._v_minus = None\n    self._g0 = None\n    self._g1 = None\n    self._g2 = None\n    self._F = None\n    self._X = None\n    self._eye_minus_qhat_qhat = None\n</code></pre>"},{"location":"reference/darkmagic/v_integrals/#darkmagic.v_integrals.MBDistribution.v_minus","title":"<code>v_minus</code>  <code>property</code>","text":"<p>Computes v_minus = min(|v_star|, Vesc) for each (q, omega) pair q: numpy array of shape (n_q, 3), momentum transfer omega: 2D numpy array of shape (n_q, n_modes), eigenmodes m_chi: float, DM mass v_e: vector, lab frame velocity of earth</p>"},{"location":"reference/darkmagic/v_integrals/#darkmagic.v_integrals.MBDistribution.g0","title":"<code>g0</code>  <code>property</code>","text":"<p>Computes the g0 integral for each (q, omega) pair See Eq. C9 in EFT paper (2009.13534)</p>"},{"location":"reference/darkmagic/v_integrals/#darkmagic.v_integrals.MBDistribution.g1","title":"<code>g1</code>  <code>property</code>","text":"<p>Computes the g1 integral for each (q, omega) pair See Eq. C11 in EFT paper (2009.13534)</p> <p>The result is a 3D array of shape (n_q, n_modes, 3) (i.e., for each q-point and mode, we get a 3-vector)</p> <p>This integral is equivalent to</p> \\[ g1 = (v_star \\hat{q} - v_e - \\vec{q}/2/m_chi) * g0 \\] this is defined slightly differently in the original <p>phonodark. Specifically,</p> \\[ g1 = (v_star R[:,2] - v_e) * g0 \\] <p>where R is a matrix that rotates \\hat{q} to lie along the z-axis</p>"},{"location":"reference/darkmagic/v_integrals/#darkmagic.v_integrals.MBDistribution.g2","title":"<code>g2</code>  <code>property</code>","text":"<p>Computes the g2 integral for each (q, omega) pair See Eq. C14 in EFT paper (2009.13534)</p> <p>The result is a 4D array of shape (n_q, n_modes, 3, 3) (i.e., for each q-point and mode, we get a 3x3 matrix)</p> <p>This suffers from a similar problem to g1, the definition in PhonoDark is quite different from the paper (including the definition of what I call F below) and I don't know how to reconcile them. It also invovles a rotation, like in g1.</p>"},{"location":"reference/darkmagic/v_integrals/#darkmagic.v_integrals.MBDistribution.F","title":"<code>F</code>  <code>property</code>","text":"<p>Computes the very last term of Eq. (C14) in the EFT paper (2009.13534) This is the term that multiplies (1 - qhat \\otimes qhat) in the g2 integral</p>"},{"location":"reference/darkmagic/v_integrals/#darkmagic.v_integrals.MBDistribution.X","title":"<code>X</code>  <code>property</code>","text":"<p>Computes the X vector for each (q, omega) pair</p> \\[ X = (\\omega / |q|) \\hat{q} - (\\mathbb{1} - \\hat{q} \\otimes \\hat{q}) v_e \\] <p>The result is a 3D array of shape (n_q, n_modes, 3)</p>"},{"location":"reference/darkmagic/v_integrals/#darkmagic.v_integrals.MBDistribution.eye_minus_qhat_qhat","title":"<code>eye_minus_qhat_qhat</code>  <code>property</code>","text":"<p>Computes the (3x3) matrix (1 - qhat \\otimes qhat) for each q-point The result is a 3D array of shape (n_q, 3, 3)</p>"},{"location":"reference/darkmagic/materials/","title":"materials","text":""},{"location":"reference/darkmagic/materials/VBTS_Magnon/","title":"VBTS_Magnon","text":""},{"location":"reference/darkmagic/materials/YIG_Magnon/","title":"YIG_Magnon","text":""},{"location":"reference/darkmagic/models/","title":"models","text":""},{"location":"reference/darkmagic/models/anapole/","title":"anapole","text":""},{"location":"reference/darkmagic/models/magnetic_dipole/","title":"magnetic_dipole","text":""}]}