{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"DarkMAGIC","text":""},{"location":"#commands","title":"Commands","text":"<ul> <li><code>mkdocs new [dir-name]</code> - Create a new project.</li> <li><code>mkdocs serve</code> - Start the live-reloading docs server.</li> <li><code>mkdocs build</code> - Build the documentation site.</li> <li><code>mkdocs -h</code> - Print help message and exit.</li> </ul>"},{"location":"#project-layout","title":"Project layout","text":"<pre><code>mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.\n</code></pre>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>darkmagic<ul> <li>constants</li> <li>io</li> <li>material</li> <li>materials<ul> <li>VBTS_Magnon</li> <li>YIG_Magnon</li> </ul> </li> <li>model</li> <li>models<ul> <li>anapole</li> <li>magnetic_dipole</li> </ul> </li> <li>numerics</li> <li>parallel</li> <li>rate</li> <li>v_integrals</li> </ul> </li> <li>docs<ul> <li>gen_ref_pages</li> </ul> </li> </ul>"},{"location":"reference/darkmagic/","title":"darkmagic","text":""},{"location":"reference/darkmagic/constants/","title":"constants","text":"<p>Constants in natural units (unless otherwise specified).</p>"},{"location":"reference/darkmagic/io/","title":"io","text":""},{"location":"reference/darkmagic/io/#darkmagic.io.write_group_from_dict","title":"<code>write_group_from_dict(hdf5_file, group_name, data_dict)</code>","text":"<p>Recurses through a dictionary and creates appropriate groups or datasets This is parallel friendly, nothing is variable length.</p> Source code in <code>darkmagic/io.py</code> <pre><code>def write_group_from_dict(hdf5_file, group_name, data_dict):\n    \"\"\"\n    Recurses through a dictionary and creates appropriate groups or datasets\n    This is parallel friendly, nothing is variable length.\n    \"\"\"\n\n    for index in data_dict:\n        if isinstance(data_dict[index], dict):\n            write_group_from_dict(hdf5_file, f\"{group_name}/{index}\", data_dict[index])\n        else:\n            data = (\n                np.array([data_dict[index]], dtype=\"S\")\n                if isinstance(data_dict[index], str)\n                else data_dict[index]\n            )\n            hdf5_file.create_dataset(f\"{group_name}/{index}\", data=data)\n</code></pre>"},{"location":"reference/darkmagic/io/#darkmagic.io.write_hdf5","title":"<code>write_hdf5(out_file, material, model, numerics, masses, times, all_total_rate_list, all_diff_rate_list, all_binned_rate_list, comm=None)</code>","text":"<p>Write data to hdf5 file</p> <p>all_*_rate_list has a complicated format. For starters, it has as many elements as there are jobs. Each element is a list of the (m_chi, time) pairs that have been computed. Each of those elements is a two element array. The first element is a tuple of the mass and time index. The second element is either a scalar (total) or an array (binned and diff). For binned and diff, the dimensions of the array are num_bins and num_modes respectively.</p> <p>So for example, if we have 4 masses and 2 times, distributed over 4 jobs, then diff_rate list will look like this: [     # This is the job 1 array, which does mass index 0 at time indices 0,1     [ [ [0, 0], [num_bins elements]], [[0, 1], [num_bins_elements], ...], # job 1     # This is the job 1 array, which does mass index 1 at time indices 0,1     [ [ [1, 0], [num_bins elements]], [[1, 1], [num_bins_elements], ...], # job 2     ... ] This format is temporary, just for backwards compatibility with PhonoDark.</p> Source code in <code>darkmagic/io.py</code> <pre><code>def write_hdf5(\n    out_file,\n    material,\n    model,\n    numerics,\n    masses,\n    times,\n    all_total_rate_list,\n    all_diff_rate_list,\n    all_binned_rate_list,\n    comm=None,\n):\n    \"\"\"\n\n    Write data to hdf5 file\n\n    all_*_rate_list has a complicated format.\n    For starters, it has as many elements as there are jobs. Each element is a list of the\n    (m_chi, time) pairs that have been computed. Each of those elements is a two element array.\n    The first element is a tuple of the mass and time index. The second element is either a scalar\n    (total) or an array (binned and diff). For binned and diff, the dimensions of the array are\n    num_bins and num_modes respectively.\n\n    So for example, if we have 4 masses and 2 times, distributed over 4 jobs, then diff_rate list will look like this:\n    [\n        # This is the job 1 array, which does mass index 0 at time indices 0,1\n        [ [ [0, 0], [num_bins elements]], [[0, 1], [num_bins_elements], ...], # job 1\n        # This is the job 1 array, which does mass index 1 at time indices 0,1\n        [ [ [1, 0], [num_bins elements]], [[1, 1], [num_bins_elements], ...], # job 2\n        ...\n    ]\n    This format is temporary, just for backwards compatibility with PhonoDark.\n    \"\"\"\n\n    def get_dicts(model, numerics, masses, times):\n        physics_parameters = {\n            # energy threshold\n            \"threshold\": 0,\n            # time of days (hr)\n            \"times\": times,\n            # - d log FDM / d log q. q dependence of mediator propagator\n            \"Fmed_power\": model.Fmed_power,\n            # power of q in the potential, used to find optimal integration mesh\n            \"power_V\": model.power_V,\n            # flag to compute for a specific model\n            # SI computes using the algorithm presented in 1910.08092\n            \"special_model\": False,\n            \"model_name\": \"mdm\",\n        }\n        dm_properties_dict = {\n            \"spin\": model.S_chi,\n            \"mass_list\": masses,\n        }\n        coeff = model.coeff\n        numerics_parameters = {\n            \"n_a\": numerics.N_grid[0],\n            \"n_b\": numerics.N_grid[1],\n            \"n_c\": numerics.N_grid[2],\n            \"power_a\": numerics.power_abc[0],\n            \"power_b\": numerics.power_abc[1],\n            \"power_c\": numerics.power_abc[2],\n            \"n_DW_x\": numerics.n_DW_xyz[0],\n            \"n_DW_y\": numerics.n_DW_xyz[1],\n            \"n_DW_z\": numerics.n_DW_xyz[2],\n            \"energy_bin_width\": numerics.bin_width,\n            \"q_cut\": numerics.use_q_cut,\n            \"special_mesh\": numerics.use_special_mesh,\n        }\n        return physics_parameters, dm_properties_dict, coeff, numerics_parameters\n\n    physics_parameters, dm_properties_dict, c_dict, numerics_parameters = get_dicts(\n        model, numerics, masses, times\n    )\n\n    # Get appropriate context manager for serial/parallel\n    if comm is None:\n        cm = h5py.File(out_file, \"w\")\n    else:\n        cm = h5py.File(out_file, \"w\", driver=\"mpio\", comm=comm)\n\n    with cm as out_f:\n        # Create groups/datasets and write out input parameters\n        write_group_from_dict(out_f, \"numerics\", numerics_parameters)\n        write_group_from_dict(out_f, \"particle_physics\", physics_parameters)\n        out_f.create_dataset(\"version\", data=np.array([\"0.0.1\"], dtype=\"S\"))\n        write_group_from_dict(\n            out_f, \"particle_physics/dm_properties\", dm_properties_dict\n        )\n        write_group_from_dict(out_f, \"particle_physics/c_coeffs\", c_dict)\n\n        num_bins = len(all_diff_rate_list[0][0][1])\n        num_modes = len(all_binned_rate_list[0][0][1])\n        # In parallel all datasets need to be created by all ranks\n        for i in range(len(physics_parameters[\"times\"])):\n            for j in range(len(dm_properties_dict[\"mass_list\"])):\n                out_f.create_dataset(f\"data/rate/{i}/{j}\", shape=(1,), dtype=\"f8\")\n                out_f.create_dataset(\n                    f\"data/diff_rate/{i}/{j}\", shape=(num_bins,), dtype=\"f8\"\n                )\n                out_f.create_dataset(\n                    f\"data/binned_rate/{i}/{j}\", shape=(num_modes,), dtype=\"f8\"\n                )\n        # Write out rates to the file\n        # To accomodate for serial, can flatten all_total_rate_list\n        for tr_list, br_list, dr_list in zip(\n            all_total_rate_list, all_binned_rate_list, all_diff_rate_list\n        ):\n            for t, b, d in zip(tr_list, br_list, dr_list):\n                # The first element of t, b, and d is a tuple of the mass and time index\n                # The second element is either a scalar (total) or an array (binned and diff)\n                # For binned and diff, the dimensions of the array are num_bins and num_modes\n                # respectively\n\n                # mass_index, time_index\n                j, i = map(str, map(int, t[0]))\n                # print(f'Writing data/rate/{i}/{j} = {t[1]} to {out_f[\"data\"][\"rate\"][i][j]}')\n                out_f[\"data\"][\"rate\"][i][j][...] = t[1]\n                out_f[\"data\"][\"binned_rate\"][i][j][...] = b[1]\n                out_f[\"data\"][\"diff_rate\"][i][j][...] = d[1]\n</code></pre>"},{"location":"reference/darkmagic/material/","title":"material","text":""},{"location":"reference/darkmagic/material/#darkmagic.material.MaterialProperties","title":"<code>MaterialProperties(N=None, S=None, L=None, L_dot_S=None, L_tens_S=None, lambda_S=None, lambda_L=None, m_psi=None)</code>","text":"Source code in <code>darkmagic/material.py</code> <pre><code>def __init__(\n    self,\n    N: dict = None,\n    S: dict = None,\n    L: dict = None,\n    L_dot_S: dict = None,\n    L_tens_S: dict = None,\n    lambda_S: ArrayLike = None,\n    lambda_L: ArrayLike = None,\n    m_psi: dict = None,\n):\n    # Phonons\n    self.N = N\n    self.S = S\n    self.L = L\n    self.L_dot_S = L_dot_S\n    self.L_tens_S = L_tens_S\n    # Magnons\n    self.lambda_S = lambda_S\n    self.lambda_L = lambda_L\n    # Mass of the particles\n    self.m_psi = m_psi\n</code></pre>"},{"location":"reference/darkmagic/material/#darkmagic.material.MaterialProperties.validate_for_phonons","title":"<code>validate_for_phonons(n_atoms)</code>","text":"<p>Validates that the material properties are suitable for phonons</p> Source code in <code>darkmagic/material.py</code> <pre><code>def validate_for_phonons(self, n_atoms: int):\n    \"\"\"\n    Validates that the material properties are suitable for phonons\n    \"\"\"\n    assert any([self.N, self.S, self.L, self.L_dot_S, self.L_tens_S])\n    self._validate_input(n_atoms)\n</code></pre>"},{"location":"reference/darkmagic/material/#darkmagic.material.MaterialProperties.validate_for_magnons","title":"<code>validate_for_magnons(n_atoms)</code>","text":"<p>Validates that the material properties are suitable for magnons</p> Source code in <code>darkmagic/material.py</code> <pre><code>def validate_for_magnons(self, n_atoms: int):\n    \"\"\"\n    Validates that the material properties are suitable for magnons\n    \"\"\"\n    assert any([np.any(self.lambda_S), np.any(self.lambda_L)])\n    # TODO: not nice to have so many return values\n    self._validate_input(n_atoms)\n</code></pre>"},{"location":"reference/darkmagic/material/#darkmagic.material.PhononMaterial","title":"<code>PhononMaterial(name, properties, phonopy_yaml_path)</code>","text":"<p>             Bases: <code>Material</code></p> Source code in <code>darkmagic/material.py</code> <pre><code>def __init__(\n    self, name: str, properties: MaterialProperties, phonopy_yaml_path: str\n):\n    # TODO: Need a check for when phonopy_yaml does not have NAC\n    phonopy_file = phonopy.load(phonopy_yaml=phonopy_yaml_path, is_nac=True)\n    self.phonopy_file = phonopy_file\n    n_atoms = phonopy_file.primitive.get_number_of_atoms()\n    self.n_modes = 3 * n_atoms\n\n    properties.validate_for_phonons(n_atoms)\n\n    m_atoms = phonopy_file.primitive.get_masses() * const.amu_to_eV\n\n    # NAC parameters (born effective charges and dielectric tensor)\n    self.born = np.array(\n        phonopy_file.nac_params.get(\"born\", np.zeros((n_atoms, 3, 3)))\n    )\n    self.epsilon = np.array(\n        phonopy_file.nac_params.get(\"dielectric\", np.identity(3))\n    )\n\n    # Create a Structure object\n    # At some point should make careful assessment of primitive vs unit_cell\n    # PhonoDark uses primitive, but what about when it's different from unit_cell?\n    positions = phonopy_file.primitive.get_scaled_positions()\n    lattice = np.array(phonopy_file.primitive.get_cell()) * const.Ang_to_inveV\n    species = phonopy_file.primitive.get_chemical_symbols()\n\n    structure = Structure(lattice, species, positions)\n\n    super().__init__(name, properties, structure, m_atoms)\n</code></pre>"},{"location":"reference/darkmagic/material/#darkmagic.material.PhononMaterial.max_dE","title":"<code>max_dE</code>  <code>property</code>","text":"<p>Returns omega_ph_max = max(omega_ph) if there are optical modes, otherwise returns the average over the entire Brillouin zone. The quantities are obviously not the same but should be the same order. See theoretical framework paper, paragraph in middle of page 24 (of published version).</p>"},{"location":"reference/darkmagic/material/#darkmagic.material.PhononMaterial.q_cut","title":"<code>q_cut</code>  <code>property</code>","text":"<p>The Debye-Waller factor supresses the rate at larger q beyond q ~ np.sqrt(m_atom * omega_ph). This is an estimate for that cutoff.</p>"},{"location":"reference/darkmagic/material/#darkmagic.material.PhononMaterial.get_eig","title":"<code>get_eig(k_points, with_eigenvectors=True)</code>","text":"<p>k_points: numpy arrays of k-points, fractional coordinates</p> Source code in <code>darkmagic/material.py</code> <pre><code>def get_eig(self, k_points: ArrayLike, with_eigenvectors: bool = True):\n    \"\"\"\n    k_points: numpy arrays of k-points, fractional coordinates\n    \"\"\"\n    # run phonopy in mesh mode\n    self.phonopy_file.run_qpoints(k_points, with_eigenvectors=with_eigenvectors)\n\n    mesh_dict = self.phonopy_file.get_qpoints_dict()\n\n    eigenvectors_pre = mesh_dict.get(\"eigenvectors\", None)\n    # convert frequencies to correct units\n    omega = const.THz_to_eV * mesh_dict[\"frequencies\"]\n\n    # Need to reshape the eigenvectors from (n_k, n_modes, n_modes)\n    # to (n_k, n_atoms, n_modes, 3)\n    if with_eigenvectors:\n        eigenvectors = np.zeros(\n            (len(k_points), self.n_modes, self.n_atoms, 3), dtype=complex\n        )\n        # TODO: Should rewrite this with a reshape...\n        for q in range(len(k_points)):\n            for nu in range(self.n_modes):\n                eigenvectors[q, nu] = np.array_split(\n                    eigenvectors_pre[q].T[nu], self.n_atoms\n                )\n    else:\n        eigenvectors = None\n\n    return omega, eigenvectors\n</code></pre>"},{"location":"reference/darkmagic/material/#darkmagic.material.MagnonMaterial","title":"<code>MagnonMaterial(name, properties, hamiltonian, m_cell, nodmi=False, noaniso=False)</code>","text":"<p>             Bases: <code>Material</code></p> <p>So m_cell needs to be specified separately</p> Source code in <code>darkmagic/material.py</code> <pre><code>def __init__(\n    self,\n    name: str,\n    properties: MaterialProperties,\n    hamiltonian: SpinHamiltonian,\n    m_cell: float,\n    nodmi=False,\n    noaniso=False,\n):\n    \"\"\"\n    In the current implementation, the hamiltonian only\n    contains the magnetic atoms and their interactions.\n    So m_cell needs to be specified separately\n    \"\"\"\n    # Ensure the hamiltonian is in the correct units\n    # hamiltonian.cell *= const.Ang_to_inveV\n    # In the future we should have a check that it comes in in units of A\n    # And convert it here\n    self.hamiltonian = hamiltonian\n    n_atoms = len(hamiltonian.magnetic_atoms)\n    self.n_modes = n_atoms\n    self.dispersion = MagnonDispersion(\n        hamiltonian, phase_convention=\"tanner\", nodmi=nodmi, noaniso=noaniso\n    )\n\n    n_atoms = len(hamiltonian.magnetic_atoms)  # Number of magnetic atoms\n    properties.validate_for_magnons(n_atoms)\n    # Atom positions in cartesian coordinates (units of 1/eV)\n    self.xj = np.array(\n        [\n            hamiltonian.get_atom_coordinates(atom, relative=False)\n            for atom in hamiltonian.magnetic_atoms\n        ]\n    )\n    # sqrt(Sj/2)\n    self.sqrt_spins_2 = np.sqrt(\n        np.array([atom.spin for atom in hamiltonian.magnetic_atoms]) / 2\n    )\n    # The vectors for rotating to local coordiante system\n    self.rj = self.dispersion.u\n\n    positions = np.array([a.position for a in hamiltonian.magnetic_atoms])\n    lattice = hamiltonian.cell\n    species = [a.type for a in hamiltonian.magnetic_atoms]\n    structure = Structure(lattice, species, positions)\n\n    m_atoms = [m_cell / n_atoms] * n_atoms\n    super().__init__(name, properties, structure, m_atoms)\n</code></pre>"},{"location":"reference/darkmagic/material/#darkmagic.material.MagnonMaterial.max_dE","title":"<code>max_dE</code>  <code>property</code>","text":"<p>Returns the maximum dE possible for the material. For magnons, we estimate this as roughly 3 * the highest magnon frequency at the BZ boundary. (At gamma point will be 0 if there are no gapped modes).</p>"},{"location":"reference/darkmagic/material/#darkmagic.material.MagnonMaterial.q_cut","title":"<code>q_cut</code>  <code>property</code>","text":"<p>For magnons there is no q_cut so we set this to a very large number.</p>"},{"location":"reference/darkmagic/material/#darkmagic.material.MagnonMaterial.get_eig","title":"<code>get_eig(k, G=None)</code>","text":"<p>k: single k-point, cartesian coordinates (units of eV) G: single G-point, cartesian coordinates (units of eV)</p> Source code in <code>darkmagic/material.py</code> <pre><code>def get_eig(self, k, G=None):\n    \"\"\"\n    k: single k-point, cartesian coordinates (units of eV)\n    G: single G-point, cartesian coordinates (units of eV)\n    \"\"\"\n    if G is None:\n        G = np.array([0, 0, 0])\n    # Calculate the prefactor\n    prefactor = self.sqrt_spins_2 * np.exp(1j * np.dot(self.xj, G))\n\n    # See Tanner's Disseration and RadTools doc for explanation of the 1/2\n    N = self.n_atoms\n    omega_nu_k, Tk = self._get_omega_T(self.dispersion.h(k) / 2)\n    Uk_conj = np.conjugate(Tk[:N, :N])  # This is U_{j,nu,k})*\n    V_minusk = np.conjugate(Tk[N:, :N])  # This is ((V_{j,nu,-k})*)*\n\n    epsilon_nu_k_G = (prefactor[:, None] * V_minusk).T @ np.conjugate(self.rj) + (\n        prefactor[:, None] * Uk_conj\n    ).T @ self.rj\n\n    return omega_nu_k, epsilon_nu_k_G  # n, and nx3 array of complex numbers\n</code></pre>"},{"location":"reference/darkmagic/model/","title":"model","text":""},{"location":"reference/darkmagic/model/#darkmagic.model.Model","title":"<code>Model(name, coeff, coeff_qmS, Fmed_power=0, power_V=0, S_chi=0.5)</code>","text":"<p>power_V: float, power of q in the V term (for special mesh) s_chi float, spin of DM particle</p> Source code in <code>darkmagic/model.py</code> <pre><code>def __init__(\n    self,\n    name: str,\n    coeff: dict,\n    coeff_qmS: dict,\n    Fmed_power: int = 0,\n    power_V: int = 0,\n    S_chi: float = 0.5,\n):\n    \"\"\"\n    name: string\n    Fmed_power: float, negative power of q in the Fmed term\n    power_V: float, power of q in the V term (for special mesh)\n    s_chi float, spin of DM particle\n    \"\"\"\n    self.name = name\n\n    self.Fmed_power = Fmed_power\n    self.power_V = power_V\n    self.S_chi = S_chi\n    self.coeff = coeff\n    self.coeff_qmS = coeff_qmS  # Needs better name\n    self.operators, self.particles = self.get_operators_and_fermions(coeff)\n</code></pre>"},{"location":"reference/darkmagic/model/#darkmagic.model.Model.screen_coeff","title":"<code>screen_coeff(q, m_chi, epsilon)</code>","text":"<p>Screen the coefficients by the form factor</p> Source code in <code>darkmagic/model.py</code> <pre><code>def screen_coeff(self, q, m_chi, epsilon):\n    \"\"\"\n    Screen the coefficients by the form factor\n    \"\"\"\n    q2_qepsq = np.linalg.norm(q, axis=1) ** 2 / np.einsum(\n        \"ij,jk,ik-&gt;i\", q, epsilon, q\n    )\n    screened_coeff_qmS = {alpha: {} for alpha in self.operators}\n    for alpha, c_alpha in self.coeff.items():\n        screened_c = {\n            \"e\": q2_qepsq * c_alpha.get(\"e\", 0),\n            \"n\": c_alpha.get(\"n\", 0),\n            \"p\": c_alpha.get(\"p\", 0) + (1 - q2_qepsq) * c_alpha.get(\"e\", 0),\n        }\n        for psi in c_alpha.keys():\n            screened_coeff_qmS[alpha][psi] = screened_c[psi] * self.coeff_qmS(\n                alpha, psi, q, m_chi, self.S_chi\n            )\n</code></pre>"},{"location":"reference/darkmagic/model/#darkmagic.model.Model.get_operators_and_fermions","title":"<code>get_operators_and_fermions(coeff)</code>  <code>staticmethod</code>","text":"<p>Gets the non-zero operators and particles (psi) from the c_dict</p> Source code in <code>darkmagic/model.py</code> <pre><code>@staticmethod\ndef get_operators_and_fermions(coeff):\n    \"\"\"\n    Gets the non-zero operators and particles (psi) from the c_dict\n    \"\"\"\n\n    nonzero_pairs = [\n        (alpha, psi)\n        for alpha, c_alpha in coeff.items()\n        for psi, c_psi in c_alpha.items()\n        if c_psi != 0\n    ]\n    return {pair[0] for pair in nonzero_pairs}, {pair[1] for pair in nonzero_pairs}\n</code></pre>"},{"location":"reference/darkmagic/numerics/","title":"numerics","text":""},{"location":"reference/darkmagic/numerics/#darkmagic.numerics.Grid","title":"<code>Grid(m_chi, v_e, numerics, material)</code>","text":"Source code in <code>darkmagic/numerics.py</code> <pre><code>def __init__(self, m_chi, v_e, numerics, material):\n    # Get q and G vectors\n    q_cut = material.q_cut if numerics.use_q_cut else 1e10\n    self.q_max = min(2 * m_chi * (const.VESC + const.VE), q_cut)\n    self.q_cart, self.q_frac = self._get_q_points(\n        numerics.N_grid, m_chi, v_e, material.recip_cart_to_frac\n    )\n    # These show up in many so it's efficient to compute them only once\n    self.q_norm = LA.norm(self.q_cart, axis=1)\n    self.q_hat = self.q_cart / self.q_norm[:, None]\n\n    # Get G-vectors\n    self.G_cart, self.G_frac = self._get_G_vectors(material.recip_frac_to_cart)\n    # Deriving this is straightforward, remember we're sampling\n    # with a power of 2 in the q direction, hence the square roots on |q|\n    self.jacobian = 8 * np.pi * self.q_norm ** (5 / 2) * self.q_max ** (1 / 2)\n\n    # Get the k-vectors\n    self.k_frac = self.q_frac - self.G_frac\n    self.k_cart = np.matmul(self.k_frac, material.recip_frac_to_cart)\n</code></pre>"},{"location":"reference/darkmagic/parallel/","title":"parallel","text":""},{"location":"reference/darkmagic/parallel/#darkmagic.parallel.distribute_load","title":"<code>distribute_load(n_proc, masses, times)</code>","text":"<p>This function distributes the load of jobs across the available processors. It attempts to balance the load as much as possible.</p> Source code in <code>darkmagic/parallel.py</code> <pre><code>def distribute_load(n_proc, masses, times):\n    \"\"\"\n    This function distributes the load of jobs across the available processors.\n    It attempts to balance the load as much as possible.\n    \"\"\"\n    # TODO: change to logging\n    print(\"Distributing load among processors.\")\n    # Our jobs list is a list of tuples, where each tuple is a pair of (mass, time) indices\n    total_job_list = np.array(\n        list(itertools.product(range(len(masses)), range(len(times))))\n    )\n    n_jobs = len(total_job_list)\n\n    base_jobs_per_proc = n_jobs // n_proc  # each processor has at least this many jobs\n    extra_jobs = 1 if n_jobs % n_proc else 0  # might need 1 more job on some processors\n    # Note a fan of using a sentinel value to indicate a \"do nothing\" job\n    job_list = JOB_SENTINEL * np.ones(\n        (n_proc, base_jobs_per_proc + extra_jobs, 2), dtype=int\n    )\n\n    for i in range(n_jobs):\n        proc_index = i % n_proc\n        job_index = i // n_proc\n        job_list[proc_index, job_index] = total_job_list[i]\n\n    if n_jobs &gt; n_proc:\n        print(\"Number of jobs exceeds the number of processors.\")\n        print(f\"Baseline number of jobs per processor: {str(base_jobs_per_proc)}\")\n        print(\n            \"Remaining processors with one extra job: \"\n            + str(n_jobs - n_proc * base_jobs_per_proc)\n        )\n    elif n_jobs &lt; n_proc:\n        print(\"Number of jobs is fewer than the number of processors.\")\n        print(\"Consider reducing the number of processors for more efficiency.\")\n        print(f\"Total number of jobs: {n_jobs}\")\n    else:\n        print(\"Number of jobs matches the number of processors. Maximally parallized.\")\n\n    return job_list\n</code></pre>"},{"location":"reference/darkmagic/rate/","title":"rate","text":""},{"location":"reference/darkmagic/rate/#darkmagic.rate.Calculation","title":"<code>Calculation(m_chi, material, model, numerics, time=0, v_e=None)</code>","text":"<p>Generic class for calculating the differential rate</p> Source code in <code>darkmagic/rate.py</code> <pre><code>def __init__(\n    self,\n    m_chi: float,\n    material: MagnonMaterial,\n    model: Model,\n    numerics: Numerics,\n    time: float | None = 0,\n    v_e: ArrayLike | None = None,\n):\n    self.m_chi = m_chi\n    if time is None and v_e is None:\n        raise ValueError(\"Either time or v_e must be provided\")\n    if time is not None and v_e is not None:\n        raise ValueError(\"Only one of time or v_e should be provided\")\n    self.v_e = self.compute_ve(time) if time is not None else v_e\n    self.material = material\n    self.model = model\n    self.numerics = numerics\n    self.grid = numerics.get_grid(m_chi, self.v_e, material)\n</code></pre>"},{"location":"reference/darkmagic/rate/#darkmagic.rate.Calculation.compute_ve","title":"<code>compute_ve(t)</code>","text":"<p>Returns the earth's velocity in the lab frame at time t (in hours)</p> Source code in <code>darkmagic/rate.py</code> <pre><code>def compute_ve(self, t: float):\n    \"\"\"\n    Returns the earth's velocity in the lab frame at time t (in hours)\n    \"\"\"\n    phi = 2 * np.pi * (t / 24.0)\n    theta = const.theta_earth\n\n    return const.VE * np.array(\n        [\n            np.sin(theta) * np.sin(phi),\n            np.cos(theta) * np.sin(theta) * (np.cos(phi) - 1),\n            (np.sin(theta) ** 2) * np.cos(phi) + np.cos(theta) ** 2,\n        ]\n    )\n</code></pre>"},{"location":"reference/darkmagic/rate/#darkmagic.rate.MagnonCalculation","title":"<code>MagnonCalculation(m_chi, material, model, numerics, time=0, v_e=None)</code>","text":"<p>             Bases: <code>Calculation</code></p> <p>Class for calculating the differential rate for magnon scattering</p> Source code in <code>darkmagic/rate.py</code> <pre><code>def __init__(\n    self,\n    m_chi: float,\n    material: MagnonMaterial,\n    model: Model,\n    numerics: Numerics,\n    time: float | None = 0,\n    v_e: ArrayLike | None = None,\n):\n    self.m_chi = m_chi\n    if time is None and v_e is None:\n        raise ValueError(\"Either time or v_e must be provided\")\n    if time is not None and v_e is not None:\n        raise ValueError(\"Only one of time or v_e should be provided\")\n    self.v_e = self.compute_ve(time) if time is not None else v_e\n    self.material = material\n    self.model = model\n    self.numerics = numerics\n    self.grid = numerics.get_grid(m_chi, self.v_e, material)\n</code></pre>"},{"location":"reference/darkmagic/rate/#darkmagic.rate.MagnonCalculation.calculate_rate","title":"<code>calculate_rate()</code>","text":"<p>Computes the differential rate</p> Source code in <code>darkmagic/rate.py</code> <pre><code>def calculate_rate(\n    self,\n):\n    \"\"\"\n    Computes the differential rate\n    \"\"\"\n\n    max_bin_num = math.ceil(self.material.max_dE / self.numerics.bin_width)\n\n    n_modes = self.material.n_modes\n    n_q = len(self.grid.q_cart)\n\n    diff_rate = np.zeros(max_bin_num, dtype=complex)\n    binned_rate = np.zeros(n_modes, dtype=complex)\n    omegas = np.zeros((n_q, n_modes))\n    epsilons = np.zeros((n_q, n_modes, 3), dtype=complex)\n\n    model_name = self.model.name\n\n    # TODO: implement this without a loop?\n    for iq, (G, k) in enumerate(zip(self.grid.G_cart, self.grid.k_cart)):\n        if iq % 1000 == 0:\n            print(f\"* m_chi = {self.m_chi:13.4f}, q-point: {iq:6d}/{n_q:6d})\")\n        omegas[iq, :], epsilons[iq, :, :] = self.material.get_eig(k, G)\n\n    v_dist = MBDistribution(self.grid, omegas, self.m_chi, self.v_e)\n\n    # Along with omega and epsilons, these are all q*nu arrays\n    bin_num = np.floor((omegas) / self.numerics.bin_width).astype(int)\n    g0 = v_dist.g0\n\n    if model_name == \"mdm\":\n        sigma_nu_q = self.sigma_mdm(self.grid.q_cart, epsilons)\n    elif model_name == \"ap\":\n        sigma_nu_q = self.sigma_ap(self.grid.q_cart, epsilons)\n    tiled_jacobian = np.tile(self.grid.jacobian, (n_modes, 1)).T\n\n    # Integrate to get deltaR\n    vol_element = tiled_jacobian * (\n        (2 * np.pi) ** 3 * np.prod(self.numerics.N_grid)\n    ) ** (-1)\n    deltaR = (\n        (1 / self.material.m_cell)\n        * (const.rho_chi / self.m_chi)\n        * vol_element\n        * sigma_nu_q\n        * g0\n    )\n\n    # Get diff rate, binned rate and total rate\n    diff_rate = np.zeros(max_bin_num)\n    np.add.at(diff_rate, bin_num, deltaR)\n    binned_rate = np.sum(deltaR, axis=0)\n    total_rate = sum(diff_rate)\n\n    return [diff_rate, binned_rate, total_rate]\n</code></pre>"},{"location":"reference/darkmagic/v_integrals/","title":"v_integrals","text":""},{"location":"reference/darkmagic/v_integrals/#darkmagic.v_integrals.MBDistribution","title":"<code>MBDistribution(grid, omega, m_chi, v_e)</code>","text":"<p>Class for truncated Maxwell-Boltzmann distribution</p> Source code in <code>darkmagic/v_integrals.py</code> <pre><code>def __init__(self, grid, omega, m_chi, v_e) -&gt; None:\n    self.grid = grid\n    self.omega = omega\n    self.m_chi = m_chi\n    self.v_e = np.array(v_e)\n\n    # Internal variables\n    self._v_minus = None\n    self._g0 = None\n    self._g1 = None\n    self._g2 = None\n    self._F = None\n    self._X = None\n    self._eye_minus_qhat_qhat = None\n</code></pre>"},{"location":"reference/darkmagic/v_integrals/#darkmagic.v_integrals.MBDistribution.v_minus","title":"<code>v_minus</code>  <code>property</code>","text":"<p>Computes v_minus = min(|v_star|, Vesc) for each (q, omega) pair q: numpy array of shape (n_q, 3), momentum transfer omega: 2D numpy array of shape (n_q, n_modes), eigenmodes m_chi: float, DM mass v_e: vector, lab frame velocity of earth</p>"},{"location":"reference/darkmagic/v_integrals/#darkmagic.v_integrals.MBDistribution.g0","title":"<code>g0</code>  <code>property</code>","text":"<p>Computes the g0 integral for each (q, omega) pair See Eq. C9 in EFT paper (2009.13534)</p>"},{"location":"reference/darkmagic/v_integrals/#darkmagic.v_integrals.MBDistribution.g1","title":"<code>g1</code>  <code>property</code>","text":"<p>Computes the g1 integral for each (q, omega) pair See Eq. C11 in EFT paper (2009.13534)</p> <p>The result is a 3D array of shape (n_q, n_modes, 3) (i.e., for each q-point and mode, we get a 3-vector)</p> <p>This integral is equivalent to</p> <p>g1 = (v_star \\hat{q} - v_e - \u000bec{q}/2/m_chi) * g0</p> this is defined slightly differently in the original <p>phonodark. Specifically,</p> <p>g1 = (v_star R[:,2] - v_e) * g0</p> <p>where R is a matrix that rotates \\hat{q} to lie along the z-axis</p>"},{"location":"reference/darkmagic/v_integrals/#darkmagic.v_integrals.MBDistribution.g2","title":"<code>g2</code>  <code>property</code>","text":"<p>Computes the g2 integral for each (q, omega) pair See Eq. C14 in EFT paper (2009.13534)</p> <p>The result is a 4D array of shape (n_q, n_modes, 3, 3) (i.e., for each q-point and mode, we get a 3x3 matrix)</p> <p>This suffers from a similar problem to g1, the definition in PhonoDark is quite different from the paper (including the definition of what I call F below) and I don't know how to reconcile them. It also invovles a rotation, like in g1.</p>"},{"location":"reference/darkmagic/v_integrals/#darkmagic.v_integrals.MBDistribution.F","title":"<code>F</code>  <code>property</code>","text":"<p>Computes the very last term of Eq. (C14) in the EFT paper (2009.13534) This is the term that multiplies (1 - qhat \\otimes qhat) in the g2 integral</p>"},{"location":"reference/darkmagic/v_integrals/#darkmagic.v_integrals.MBDistribution.X","title":"<code>X</code>  <code>property</code>","text":"<p>Computes the X vector for each (q, omega) pair</p> <p>X = (\\omega / |q|) \\hat{q} - (\\mathbb{1} - \\hat{q} \\otimes \\hat{q}) v_e</p> <p>The result is a 3D array of shape (n_q, n_modes, 3)</p>"},{"location":"reference/darkmagic/v_integrals/#darkmagic.v_integrals.MBDistribution.eye_minus_qhat_qhat","title":"<code>eye_minus_qhat_qhat</code>  <code>property</code>","text":"<p>Computes the (3x3) matrix (1 - qhat \\otimes qhat) for each q-point The result is a 3D array of shape (n_q, 3, 3)</p>"},{"location":"reference/darkmagic/materials/","title":"materials","text":""},{"location":"reference/darkmagic/materials/VBTS_Magnon/","title":"VBTS_Magnon","text":""},{"location":"reference/darkmagic/materials/YIG_Magnon/","title":"YIG_Magnon","text":""},{"location":"reference/darkmagic/models/","title":"models","text":""},{"location":"reference/darkmagic/models/anapole/","title":"anapole","text":""},{"location":"reference/darkmagic/models/magnetic_dipole/","title":"magnetic_dipole","text":""},{"location":"reference/docs/gen_ref_pages/","title":"gen_ref_pages","text":"<p>Generate the code reference pages and navigation.</p>"}]}