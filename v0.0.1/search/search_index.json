{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"DarkMAGIC","text":""},{"location":"#commands","title":"Commands","text":"<ul> <li><code>mkdocs new [dir-name]</code> - Create a new project.</li> <li><code>mkdocs serve</code> - Start the live-reloading docs server.</li> <li><code>mkdocs build</code> - Build the documentation site.</li> <li><code>mkdocs -h</code> - Print help message and exit.</li> </ul>"},{"location":"#project-layout","title":"Project layout","text":"<pre><code>mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.\n</code></pre>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>darkmagic<ul> <li>analysis</li> <li>benchmark_models<ul> <li>anapole</li> <li>hadrophilic_scalar_mediator</li> <li>magnetic_dipole</li> <li>utils</li> </ul> </li> <li>constants</li> <li>io</li> <li>material</li> <li>materials<ul> <li>VBTS_Magnon</li> <li>YIG_Magnon</li> </ul> </li> <li>model</li> <li>numerics</li> <li>parallel</li> <li>rate</li> <li>v_integrals</li> </ul> </li> </ul>"},{"location":"reference/darkmagic/","title":"darkmagic","text":""},{"location":"reference/darkmagic/analysis/","title":"analysis","text":""},{"location":"reference/darkmagic/analysis/#darkmagic.analysis.get_reach","title":"<code>get_reach(filename, threshold_meV=1.0, exposure_kg_yr=1.0, n_cut=3.0, model=None, time=0)</code>","text":"<p>Computes the projected reach: the 95% C.L. constraint (3 events, no background) on \\(\bar{sigma}_n\\) or \\(\bar{sigma}_e\\) for a given model, in units of cm2 and normalizing to the appropriate reference cross section.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The path to the HDF5 file containing the data.</p> required <code>threshold_meV</code> <code>float</code> <p>The threshold in meV. Defaults to 1.0.</p> <code>1.0</code> <code>exposure_kg_yr</code> <code>float</code> <p>The exposure in kg.yr. Defaults to 1.0.</p> <code>1.0</code> <code>n_cut</code> <code>float</code> <p>The number of events. Defaults to 3.0.</p> <code>3.0</code> <code>model</code> <code>str</code> <p>The model to use. Defaults to None (find it in file)</p> <code>None</code> <code>time</code> <code>float | str</code> <p>The time to use. Defaults to 0.</p> <code>0</code> <p>Returns:</p> Type Description <code>array</code> <p>np.array: the cross section.</p> Source code in <code>darkmagic/analysis.py</code> <pre><code>def get_reach(\n    filename: str,\n    threshold_meV: float = 1.0,\n    exposure_kg_yr: float = 1.0,\n    n_cut: float = 3.0,\n    model: str | None = None,\n    time: float | str = 0,\n) -&gt; np.array:\n    \"\"\"\n    Computes the projected reach: the 95% C.L. constraint (3 events, no background) on $\\bar{sigma}_n$ or $\\bar{sigma}_e$ for a given model, in units of cm2 and normalizing to the appropriate reference cross section.\n\n    Args:\n        filename (str): The path to the HDF5 file containing the data.\n        threshold_meV (float, optional): The threshold in meV. Defaults to 1.0.\n        exposure_kg_yr (float, optional): The exposure in kg.yr. Defaults to 1.0.\n        n_cut (float, optional): The number of events. Defaults to 3.0.\n        model (str, optional): The model to use. Defaults to None (find it in file)\n        time (float | str, optional): The time to use. Defaults to 0.\n\n    Returns:\n        np.array: the cross section.\n    \"\"\"\n\n    with h5py.File(filename, \"r\") as f:\n        energy_bin_width = f[\"numerics\"][\"energy_bin_width\"][...]\n        threshold = f[\"particle_physics\"][\"threshold\"][...]\n        m_chi = np.array(f[\"particle_physics\"][\"dm_properties\"][\"mass_list\"])\n        raw_binned_rate = 1e-100 + np.array(  # 1e-100 to avoid division by zero\n            [\n                np.array(f[\"data\"][\"diff_rate\"][str(time)][str(m)])\n                for m in range(len(m_chi))\n            ]\n        )\n        # TODO: add check to see if model is there\n\n    # Vanilla PhonoDark, have a threshold of 1 meV by default\n    # We need to account for that in the binning\n    bin_num_cut = int(threshold_meV * 1e-3 / energy_bin_width) - int(\n        threshold / energy_bin_width\n    )\n\n    cs_constraint = n_cut / np.sum(raw_binned_rate[:, bin_num_cut:], axis=1)\n    cs_constraint /= (\n        exposure_kg_yr\n        * const.kg_yr\n        * const.cm2\n        * BUILT_IN_MODELS[model].ref_cross_sect(m_chi)\n    )\n\n    return cs_constraint\n</code></pre>"},{"location":"reference/darkmagic/constants/","title":"constants","text":"<p>Constants in natural units (unless otherwise specified).</p>"},{"location":"reference/darkmagic/io/","title":"io","text":""},{"location":"reference/darkmagic/io/#darkmagic.io.write_group_from_dict","title":"<code>write_group_from_dict(hdf5_file, group_name, data_dict)</code>","text":"<p>Recurses through a dictionary and creates appropriate groups or datasets This is parallel friendly, nothing is variable length.</p> Source code in <code>darkmagic/io.py</code> <pre><code>def write_group_from_dict(hdf5_file, group_name, data_dict):\n    \"\"\"\n    Recurses through a dictionary and creates appropriate groups or datasets\n    This is parallel friendly, nothing is variable length.\n    \"\"\"\n\n    for index in data_dict:\n        if isinstance(data_dict[index], dict):\n            write_group_from_dict(hdf5_file, f\"{group_name}/{index}\", data_dict[index])\n        else:\n            data = (\n                np.array([data_dict[index]], dtype=\"S\")\n                if isinstance(data_dict[index], str)\n                else data_dict[index]\n            )\n            hdf5_file.create_dataset(f\"{group_name}/{index}\", data=data)\n</code></pre>"},{"location":"reference/darkmagic/io/#darkmagic.io.write_hdf5","title":"<code>write_hdf5(out_file, material, model, numerics, masses, times, all_total_rate_list, all_diff_rate_list, all_binned_rate_list, comm=None)</code>","text":"<p>Write data to hdf5 file</p> <p>all_*_rate_list has a complicated format. For starters, it has as many elements as there are jobs. Each element is a list of the (m_chi, time) pairs that have been computed. Each of those elements is a two element array. The first element is a tuple of the mass and time index. The second element is either a scalar (total) or an array (binned and diff). For binned and diff, the dimensions of the array are num_bins and num_modes respectively.</p> <p>So for example, if we have 4 masses and 2 times, distributed over 4 jobs, then diff_rate list will look like this: [     # This is the job 1 array, which does mass index 0 at time indices 0,1     [ [ [0, 0], [num_bins elements]], [[0, 1], [num_bins_elements], ...], # job 1     # This is the job 1 array, which does mass index 1 at time indices 0,1     [ [ [1, 0], [num_bins elements]], [[1, 1], [num_bins_elements], ...], # job 2     ... ] This format is temporary, just for backwards compatibility with PhonoDark.</p> <p>Args: - out_file: Path to the output HDF5 file. - material: Material object. - model: Model object. - numerics: Numerics object. - masses: List of masses for the jobs. - times: List of times for the jobs. - all_total_rate_list: List of total rate data. - all_diff_rate_list: List of differential rate data. - all_binned_rate_list: List of binned rate data. - comm: MPI communicator for parallel writing (default is None).</p> <p>Returns: - None</p> Source code in <code>darkmagic/io.py</code> <pre><code>def write_hdf5(\n    out_file,\n    material,\n    model,\n    numerics,\n    masses,\n    times,\n    all_total_rate_list,\n    all_diff_rate_list,\n    all_binned_rate_list,\n    comm=None,\n):\n    \"\"\"\n\n    Write data to hdf5 file\n\n    all_*_rate_list has a complicated format.\n    For starters, it has as many elements as there are jobs. Each element is a list of the\n    (m_chi, time) pairs that have been computed. Each of those elements is a two element array.\n    The first element is a tuple of the mass and time index. The second element is either a scalar\n    (total) or an array (binned and diff). For binned and diff, the dimensions of the array are\n    num_bins and num_modes respectively.\n\n    So for example, if we have 4 masses and 2 times, distributed over 4 jobs, then diff_rate list will look like this:\n    [\n        # This is the job 1 array, which does mass index 0 at time indices 0,1\n        [ [ [0, 0], [num_bins elements]], [[0, 1], [num_bins_elements], ...], # job 1\n        # This is the job 1 array, which does mass index 1 at time indices 0,1\n        [ [ [1, 0], [num_bins elements]], [[1, 1], [num_bins_elements], ...], # job 2\n        ...\n    ]\n    This format is temporary, just for backwards compatibility with PhonoDark.\n\n    Args:\n    - out_file: Path to the output HDF5 file.\n    - material: Material object.\n    - model: Model object.\n    - numerics: Numerics object.\n    - masses: List of masses for the jobs.\n    - times: List of times for the jobs.\n    - all_total_rate_list: List of total rate data.\n    - all_diff_rate_list: List of differential rate data.\n    - all_binned_rate_list: List of binned rate data.\n    - comm: MPI communicator for parallel writing (default is None).\n\n    Returns:\n    - None\n    \"\"\"\n\n    def get_dicts(model, numerics, masses, times):\n        physics_parameters = {\n            # energy threshold\n            \"threshold\": 0,\n            # time of days (hr)\n            \"times\": times,\n            # - d log FDM / d log q. q dependence of mediator propagator\n            \"Fmed_power\": model.Fmed_power,\n            # power of q in the potential, used to find optimal integration mesh\n            \"power_V\": model.power_V,\n            # flag to compute for a specific model\n            # SI computes using the algorithm presented in 1910.08092\n            \"special_model\": False,\n            \"model_name\": \"mdm\",\n        }\n        dm_properties_dict = {\n            \"spin\": model.S_chi,\n            \"mass_list\": masses,\n        }\n        coeff = model.coeff_prefactor\n        numerics_parameters = {\n            \"n_a\": numerics.N_grid[0],\n            \"n_b\": numerics.N_grid[1],\n            \"n_c\": numerics.N_grid[2],\n            \"power_a\": numerics.power_abc[0],\n            \"power_b\": numerics.power_abc[1],\n            \"power_c\": numerics.power_abc[2],\n            \"n_DW_x\": numerics.N_DWF_grid[0],\n            \"n_DW_y\": numerics.N_DWF_grid[1],\n            \"n_DW_z\": numerics.N_DWF_grid[2],\n            \"energy_bin_width\": numerics.bin_width,\n            \"q_cut\": numerics.use_q_cut,\n            \"special_mesh\": numerics.use_special_mesh,\n        }\n        return physics_parameters, dm_properties_dict, coeff, numerics_parameters\n\n    physics_parameters, dm_properties_dict, c_dict, numerics_parameters = get_dicts(\n        model, numerics, masses, times\n    )\n\n    # Get appropriate context manager for serial/parallel\n    if comm is None:\n        cm = h5py.File(out_file, \"w\")\n    else:\n        cm = h5py.File(out_file, \"w\", driver=\"mpio\", comm=comm)\n\n    with cm as out_f:\n        # Create groups/datasets and write out input parameters\n        write_group_from_dict(out_f, \"numerics\", numerics_parameters)\n        write_group_from_dict(out_f, \"particle_physics\", physics_parameters)\n        out_f.create_dataset(\"version\", data=np.array([\"0.0.1\"], dtype=\"S\"))\n        write_group_from_dict(\n            out_f, \"particle_physics/dm_properties\", dm_properties_dict\n        )\n        write_group_from_dict(out_f, \"particle_physics/c_coeffs\", c_dict)\n\n        num_bins = len(all_diff_rate_list[0][0][1])\n        num_modes = len(all_binned_rate_list[0][0][1])\n        # In parallel all datasets need to be created by all ranks\n        for i in range(len(physics_parameters[\"times\"])):\n            for j in range(len(dm_properties_dict[\"mass_list\"])):\n                out_f.create_dataset(f\"data/rate/{i}/{j}\", shape=(1,), dtype=\"f8\")\n                out_f.create_dataset(\n                    f\"data/diff_rate/{i}/{j}\", shape=(num_bins,), dtype=\"f8\"\n                )\n                out_f.create_dataset(\n                    f\"data/binned_rate/{i}/{j}\", shape=(num_modes,), dtype=\"f8\"\n                )\n        # Write out rates to the file\n        # To accomodate for serial, can flatten all_total_rate_list\n        for tr_list, br_list, dr_list in zip(\n            all_total_rate_list, all_binned_rate_list, all_diff_rate_list\n        ):\n            for t, b, d in zip(tr_list, br_list, dr_list):\n                # The first element of t, b, and d is a tuple of the mass and time index\n                # The second element is either a scalar (total) or an array (binned and diff)\n                # For binned and diff, the dimensions of the array are num_bins and num_modes\n                # respectively\n\n                # mass_index, time_index\n                j, i = map(str, map(int, t[0]))\n                # print(f'Writing data/rate/{i}/{j} = {t[1]} to {out_f[\"data\"][\"rate\"][i][j]}')\n                out_f[\"data\"][\"rate\"][i][j][...] = t[1]\n                out_f[\"data\"][\"binned_rate\"][i][j][...] = b[1]\n                out_f[\"data\"][\"diff_rate\"][i][j][...] = d[1]\n</code></pre>"},{"location":"reference/darkmagic/material/","title":"material","text":""},{"location":"reference/darkmagic/material/#darkmagic.material.MaterialParameters","title":"<code>MaterialParameters(N=None, S=None, L=None, L_dot_S=None, L_tens_S=None, lambda_S=None, lambda_L=None, m_psi=None)</code>","text":"<p>Class for DM-relevant material properties, such as the number of fermions, spin, orbital angular momentum, etc.</p> <p>Attributes:</p> Name Type Description <code>N</code> <code>dict</code> <p>Fermion numbers.</p> <code>S</code> <code>dict</code> <p>Spin vectors.</p> <code>L</code> <code>dict</code> <p>Orbital angular momentum vectors.</p> <code>L_dot_S</code> <code>dict</code> <p>\\(L \\cdot S\\)</p> <code>L_tens_S</code> <code>dict</code> <p>Spin orbit coupling tensor \\(L \\otimes S\\)</p> <code>lambda_S</code> <code>ArrayLike</code> <p>spin-coefficient for magnons</p> <code>lambda_L</code> <code>ArrayLike</code> <p>orbital angular mom.-coefficient for magnons</p> <code>m_psi</code> <code>dict</code> <p>Dictionary of masses for different particles.</p> <p>Methods:</p> Name Description <code>validate_for_phonons</code> <p>Validates that the material properties are suitable for phonon calculations.</p> <code>validate_for_magnons</code> <p>Validates that the material properties are suitable for magnon calculations.</p> <p>Parameters:</p> Name Type Description Default <code>N</code> <code>dict</code> <p>Fermion numbers.</p> <code>None</code> <code>S</code> <code>dict</code> <p>Spin vectors.</p> <code>None</code> <code>L</code> <code>dict</code> <p>Orbital angular momentum vectors.</p> <code>None</code> <code>L_dot_S</code> <code>dict</code> <p>\\(L \\cdot S\\)</p> <code>None</code> <code>L_tens_S</code> <code>dict</code> <p>Spin orbit coupling tensor \\(L \\otimes S\\)</p> <code>None</code> <code>lambda_S</code> <code>ArrayLike</code> <p>spin-coefficient for magnons</p> <code>None</code> <code>lambda_L</code> <code>ArrayLike</code> <p>orbital angular mom.-coefficient for magnons</p> <code>None</code> <code>m_psi</code> <code>dict</code> <p>Masses of the fermions. Defaults to NIST values.</p> <code>None</code> Source code in <code>darkmagic/material.py</code> <pre><code>def __init__(\n    self,\n    N: dict = None,\n    S: dict = None,\n    L: dict = None,\n    L_dot_S: dict = None,\n    L_tens_S: dict = None,\n    lambda_S: ArrayLike = None,\n    lambda_L: ArrayLike = None,\n    m_psi: dict = None,\n):\n    r\"\"\"\n    Material properties constructor. All dicts have keys \"n\", \"p\", \"e\" for neutron, proton and electron. Any missing values are instantiated to 0.\n\n    Args:\n        N (dict, optional): Fermion numbers.\n        S (dict, optional): Spin vectors.\n        L (dict, optional): Orbital angular momentum vectors.\n        L_dot_S (dict, optional): $L \\cdot S$\n        L_tens_S (dict, optional): Spin orbit coupling tensor $L \\otimes S$\n        lambda_S (ArrayLike, optional): spin-coefficient for magnons\n        lambda_L (ArrayLike, optional): orbital angular mom.-coefficient for magnons\n        m_psi (dict, optional): Masses of the fermions. Defaults to NIST values.\n    \"\"\"\n    # Phonons\n    self.N = N\n    self.S = S\n    self.L = L\n    self.L_dot_S = L_dot_S\n    self.L_tens_S = L_tens_S\n    # Magnons\n    self.lambda_S = lambda_S\n    self.lambda_L = lambda_L\n    # Mass of the particles\n    self.m_psi = m_psi\n</code></pre>"},{"location":"reference/darkmagic/material/#darkmagic.material.MaterialParameters.validate_for_phonons","title":"<code>validate_for_phonons(n_atoms)</code>","text":"<p>Validates that the material properties are suitable for phonons. Namely, at least one of N, S, L, L_dot_S or L_tens_S must be defined.</p> <p>Parameters:</p> Name Type Description Default <code>n_atoms</code> <code>int</code> <p>Number of atoms in the material.</p> required <p>Raises:</p> Type Description <code>AssertionError</code> <p>If any of the required material properties for phonons are missing or have incorrect dimensions.</p> Source code in <code>darkmagic/material.py</code> <pre><code>def validate_for_phonons(self, n_atoms: int) -&gt; None:\n    \"\"\"\n    Validates that the material properties are suitable for phonons.\n    Namely, at least one of N, S, L, L_dot_S or L_tens_S must be defined.\n\n    Args:\n        n_atoms (int): Number of atoms in the material.\n\n    Raises:\n        AssertionError: If any of the required material properties for phonons are missing or have incorrect dimensions.\n\n    \"\"\"\n    assert any([self.N, self.S, self.L, self.L_dot_S, self.L_tens_S])\n    for d in [self.N, self.S, self.L, self.L_dot_S, self.L_tens_S]:\n        if d:\n            assert any(np.any(v) for v in d.values())\n\n    self._validate_input(n_atoms)\n</code></pre>"},{"location":"reference/darkmagic/material/#darkmagic.material.MaterialParameters.validate_for_magnons","title":"<code>validate_for_magnons(n_atoms)</code>","text":"<p>Validates that the material properties are suitable for magnons. Namely, at least one of lambda_S and lambda_L must be defined.</p> <p>Parameters:</p> Name Type Description Default <code>n_atoms</code> <code>int</code> <p>Number of atoms in the material.</p> required <p>Raises:</p> Type Description <code>AssertionError</code> <p>If any of the required material properties for magnons are missing or have incorrect dimensions.</p> Source code in <code>darkmagic/material.py</code> <pre><code>def validate_for_magnons(self, n_atoms: int) -&gt; None:\n    \"\"\"\n    Validates that the material properties are suitable for magnons. Namely, at least one of lambda_S and lambda_L must be defined.\n\n    Args:\n        n_atoms (int): Number of atoms in the material.\n\n    Raises:\n        AssertionError: If any of the required material properties for magnons are missing or have incorrect dimensions.\n\n    \"\"\"\n    assert any([np.any(self.lambda_S), np.any(self.lambda_L)])\n    # TODO: not nice to have so many return values\n    self._validate_input(n_atoms)\n</code></pre>"},{"location":"reference/darkmagic/material/#darkmagic.material.Material","title":"<code>Material(name, properties, structure, m_atoms)</code>","text":"<p>Represents a generic material with its structural and atomic properties.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>The name of the material.</p> <code>properties</code> <code>MaterialProperties</code> <p>The properties of the material.</p> <code>real_frac_to_cart</code> <code>ndarray</code> <p>The transformation matrix from fractional to Cartesian coordinates (units 1/eV), in real space.</p> <code>real_cart_to_frac</code> <code>ndarray</code> <p>The transformation matrix from Cartesian (units 1/eV) to fractional coordinates, in real space.</p> <code>recip_frac_to_cart</code> <code>ndarray</code> <p>The transformation matrix from fractional to Cartesian coordinates (units eV), in k-space.</p> <code>recip_cart_to_frac</code> <code>ndarray</code> <p>The transformation matrix from Cartesian (units eV) to fractional coordinates, in k-space.</p> <code>m_atoms</code> <code>ArrayLike</code> <p>an array of atomic masses, in eV.</p> <code>m_cell</code> <code>ndarray</code> <p>The total mass of the atoms in the material, in eV.</p> <code>xj</code> <code>ndarray</code> <p>The Cartesian coordinates (units 1/eV) of the atoms in the material.</p> <code>structure</code> <code>Structure</code> <p>the crystal structure <code>pymatgen</code> <code>Structure</code> object.</p> <code>n_atoms</code> <code>int</code> <p>The number of atoms in the material.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the material.</p> required <code>properties</code> <code>MaterialProperties</code> <p>The properties of the material.</p> required <code>structure</code> <code>Structure</code> <p>The structure of the material.</p> required <code>m_atoms</code> <code>ArrayLike</code> <p>atomic masses in eV.</p> required Source code in <code>darkmagic/material.py</code> <pre><code>def __init__(\n    self,\n    name: str,\n    properties: MaterialParameters,\n    structure: Structure,\n    m_atoms: ArrayLike,\n):\n    \"\"\"\n    Constructor for a generic Material object\n\n    Args:\n        name (str): The name of the material.\n        properties (MaterialProperties): The properties of the material.\n        structure (Structure): The structure of the material.\n        m_atoms (ArrayLike): atomic masses in eV.\n    \"\"\"\n    # Material properties\n    self.name = name\n    self.properties = properties\n\n    # Define transformation matrices\n    self.real_frac_to_cart = structure.lattice.matrix.T\n    self.real_cart_to_frac = LA.inv(self.real_frac_to_cart)\n    self.recip_frac_to_cart = structure.lattice.reciprocal_lattice.matrix.T\n    self.recip_cart_to_frac = LA.inv(self.recip_frac_to_cart)\n\n    # Atomic and structural properties\n    self.m_atoms = m_atoms\n    self.m_cell = np.sum(m_atoms)\n    self.xj = structure.cart_coords\n    self.structure = structure\n    self.n_atoms = len(structure.species)\n\n    # Internal variables\n    self._max_dE = None\n    self._q_cut = None\n</code></pre>"},{"location":"reference/darkmagic/material/#darkmagic.material.PhononMaterial","title":"<code>PhononMaterial(name, properties, phonopy_yaml_path)</code>","text":"<p>             Bases: <code>Material</code></p> <p>A class for materials with phonons.</p> <p>Attributes:</p> Name Type Description <code>phonopy_file</code> <code>Phonopy</code> <p>The Phonopy object for the material's phonons</p> <code>n_modes</code> <code>int</code> <p>The number of phonon modes in the material.</p> <code>born</code> <code>ndarray</code> <p>The born effective charges</p> <code>epsilon</code> <code>ndarray</code> <p>The dielectric tensor</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the material.</p> required <code>properties</code> <code>MaterialProperties</code> <p>The properties of the material.</p> required <code>phonopy_yaml_path</code> <code>str</code> <p>The path to the Phonopy YAML file.</p> required Source code in <code>darkmagic/material.py</code> <pre><code>def __init__(\n    self, name: str, properties: MaterialParameters, phonopy_yaml_path: str\n):\n    \"\"\"\n    Constructor for PhononMaterial objects.\n\n    Args:\n        name (str): The name of the material.\n        properties (MaterialProperties): The properties of the material.\n        phonopy_yaml_path (str): The path to the Phonopy YAML file.\n\n    \"\"\"\n    # TODO: Need a check for when phonopy_yaml does not have NAC\n    phonopy_file = phonopy.load(phonopy_yaml=phonopy_yaml_path, is_nac=True)\n    # TODO: should be a dict that has the correct factor for all codes\n    length_factor = const.bohr_to_Ang if phonopy_file.calculator == \"qe\" else 1.0\n    self.phonopy_file = phonopy_file\n    n_atoms = phonopy_file.primitive.get_number_of_atoms()\n    self.n_modes = 3 * n_atoms\n\n    properties.validate_for_phonons(n_atoms)\n\n    m_atoms = phonopy_file.primitive.masses * const.amu_to_eV\n\n    # NAC parameters (born effective charges and dielectric tensor)\n    self.born = np.array(\n        phonopy_file.nac_params.get(\"born\", np.zeros((n_atoms, 3, 3)))\n    )\n    self.epsilon = np.array(\n        phonopy_file.nac_params.get(\"dielectric\", np.identity(3))\n    )\n\n    # Create a Structure object\n    # At some point should make careful assessment of primitive vs unit_cell\n    # PhonoDark uses primitive, but what about when it's different from unit_cell?\n    positions = phonopy_file.primitive.scaled_positions\n    lattice = (\n        np.array(phonopy_file.primitive.cell) * const.Ang_to_inveV * length_factor\n    )\n    species = phonopy_file.primitive.symbols\n\n    structure = Structure(lattice, species, positions)\n\n    super().__init__(name, properties, structure, m_atoms)\n</code></pre>"},{"location":"reference/darkmagic/material/#darkmagic.material.PhononMaterial.max_dE","title":"<code>max_dE: float</code>  <code>property</code>","text":"<p>Returns omega_ph_max = max(omega_ph) if there are optical modes, otherwise returns the average over the entire Brillouin zone. The quantities are obviously not the same but should be the same order. See theoretical framework paper, paragraph in middle of page 24 (of published version).</p> <p>TODO: clarify this</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>the maximum energy deposition</p>"},{"location":"reference/darkmagic/material/#darkmagic.material.PhononMaterial.q_cut","title":"<code>q_cut: float</code>  <code>property</code>","text":"<p>The Debye-Waller factor suppresses the rate at larger q beyond q ~ np.sqrt(m_atom * omega_ph). This method calculates an estimate for the cutoff value of q.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The cutoff value of q.</p>"},{"location":"reference/darkmagic/material/#darkmagic.material.PhononMaterial.get_eig","title":"<code>get_eig(k_points, with_eigenvectors=True)</code>","text":"<p>Calculates the phonon frequencies and eigenvectors for the given k-points.</p> <p>Parameters:</p> Name Type Description Default <code>k_points</code> <code>ArrayLike</code> <p>Numpy array of k-points in fractional coordinates.</p> required <code>with_eigenvectors</code> <code>bool</code> <p>Flag indicating whether to calculate eigenvectors.</p> <code>True</code> <p>Returns:</p> Type Description <code>Tuple[ndarray, ndarray]</code> <p>A tuple containing the phonon frequencies and eigenvectors.</p> <ul> <li> <p>The phonon frequencies are represented as a numpy array of shape (n_k,n_modes)</p> </li> <li> <p>The eigenvectors are represented as a numpy array of shape (n_k, n_atoms, n_modes, 3)</p> </li> </ul> <p>where n_k is the number of k-points, n_modes is the number of modes, n_atoms is the number of atoms, and the last index is for the x, y, z components of the eigenvectors.</p> Source code in <code>darkmagic/material.py</code> <pre><code>def get_eig(\n    self, k_points: ArrayLike, with_eigenvectors: bool = True\n) -&gt; Tuple[np.ndarray, np.ndarray]:\n    \"\"\"\n    Calculates the phonon frequencies and eigenvectors for the given k-points.\n\n    Args:\n        k_points (ArrayLike): Numpy array of k-points in fractional coordinates.\n        with_eigenvectors (bool, optional): Flag indicating whether to calculate eigenvectors.\n\n    Returns:\n        A tuple containing the phonon frequencies and eigenvectors.\n\n            * The phonon frequencies are represented as a numpy array of shape (n_k,n_modes)\n\n            * The eigenvectors are represented as a numpy array of shape (n_k, n_atoms, n_modes, 3)\n\n            where n_k is the number of k-points, n_modes is the number of modes,\n            n_atoms is the number of atoms, and the last index is\n            for the x, y, z components of the eigenvectors.\n    \"\"\"\n    # run phonopy in mesh mode\n    self.phonopy_file.run_qpoints(k_points, with_eigenvectors=with_eigenvectors)\n\n    mesh_dict = self.phonopy_file.get_qpoints_dict()\n\n    eigenvectors_pre = mesh_dict.get(\"eigenvectors\", None)\n    # print(eigenvectors_pre)\n    # convert frequencies to correct units\n    omega = const.THz_to_eV * mesh_dict[\"frequencies\"]\n\n    eigenvectors = np.zeros(\n        (len(k_points), self.n_modes, self.n_atoms, 3), dtype=complex\n    )\n    # Need to reshape the eigenvectors from (n_k, n_modes, n_modes)\n    # to (n_k, n_modes, n_atoms, 3) # TODO: is this correct?\n    if with_eigenvectors:\n        # TODO: Should rewrite this with a reshape...\n        for q in range(len(k_points)):\n            for nu in range(self.n_modes):\n                eigenvectors[q, nu] = np.array_split(\n                    eigenvectors_pre[q].T[nu], self.n_atoms\n                )\n\n    return omega, eigenvectors\n</code></pre>"},{"location":"reference/darkmagic/material/#darkmagic.material.PhononMaterial.get_W_tensor","title":"<code>get_W_tensor(grid)</code>","text":"<p>Computes the W tensor for the given Monkhorst-Pack grid. The W tensor for atom \\(j\\) is given by: $$ \\mathbf{W}j = \\frac{\\Omega}{4 m_j} \\sum\\nu \\int_\\text{1BZ} \\frac{d^3k}{(2\\pi)^3} \\frac{\\epsilon_{\\nu j \\bm{k}} \\otimes \\epsilon_{\\nu j \\bm{k}}^*}{\\omega_{\\nu \\bm{k}}} $$</p> <p>The Debye-Waller factor can be computed from the W tensor as: $$ W_j(\\bm{q}) = \\bm{q} \\cdot (\\mathbf{W}_j \\bm{q}) $$</p> <p>Parameters:</p> Name Type Description Default <code>grid</code> <code>MonkhorstPackGrid</code> <p>The Monkhorst-Pack grid.</p> required <p>Returns:</p> Type Description <code>ndarray</code> <p>np.ndarray: The W tensor.</p> Source code in <code>darkmagic/material.py</code> <pre><code>def get_W_tensor(self, grid: MonkhorstPackGrid) -&gt; np.ndarray:\n    r\"\"\"\n    Computes the W tensor for the given Monkhorst-Pack grid. The W tensor for atom $j$ is given by:\n    $$\n    \\mathbf{W}_j = \\frac{\\Omega}{4 m_j} \\sum_\\nu \\int_\\text{1BZ} \\frac{d^3k}{(2\\pi)^3} \\frac{\\epsilon_{\\nu j \\bm{k}} \\otimes \\epsilon_{\\nu j \\bm{k}}^*}{\\omega_{\\nu \\bm{k}}}\n    $$\n\n    The Debye-Waller factor can be computed from the W tensor as:\n    $$\n    W_j(\\bm{q}) = \\bm{q} \\cdot (\\mathbf{W}_j \\bm{q})\n    $$\n\n    Args:\n        grid (MonkhorstPackGrid): The Monkhorst-Pack grid.\n\n    Returns:\n        np.ndarray: The W tensor.\n\n    \"\"\"\n    omega, epsilon = self.get_eig(grid.k_frac)\n    # epsilon is (n_k, n_modes, n_atoms, 3)\n    eps_tensor = np.einsum(\"...i,...j-&gt;...ij\", epsilon, np.conj(epsilon))\n\n    # Sum over all modes and divide by the frequency\n    W = (\n        1\n        / (4 * self.m_atoms[None, :, None, None])\n        * np.sum(eps_tensor / omega[..., None, None, None], axis=1)\n    )\n    # Integrate over the BZ\n    return np.sum(W * grid.weights[:, None, None, None], axis=0) / np.sum(\n        grid.weights\n    )\n</code></pre>"},{"location":"reference/darkmagic/material/#darkmagic.material.MagnonMaterial","title":"<code>MagnonMaterial(name, properties, hamiltonian, m_cell, nodmi=False, noaniso=False)</code>","text":"<p>             Bases: <code>Material</code></p> <p>A class for materials with magnons</p> <p>Attributes:</p> Name Type Description <code>hamiltonian</code> <code>SpinHamiltonian</code> <p>The spin Hamiltonian of the material.</p> <code>n_modes</code> <code>int</code> <p>The number of magnon modes.</p> <code>dispersion</code> <code>MagnonDispersion</code> <p>The magnon dispersion.</p> <p>In the current implementation, the hamiltonian only contains the magnetic atoms and their interactions. So m_cell needs to be specified separately</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the material.</p> required <code>properties</code> <code>MaterialParameters</code> <p>The properties of the material.</p> required <code>hamiltonian</code> <code>SpinHamiltonian</code> <p>The spin Hamiltonian</p> required <code>m_cell</code> <code>float</code> <p>the total mass of all ions in the cell</p> required <code>nodmi</code> <code>bool</code> <p>Whether to include DM interactions.</p> <code>False</code> <code>noaniso</code> <code>bool</code> <p>Whether to include anisotropic exchange.</p> <code>False</code> Source code in <code>darkmagic/material.py</code> <pre><code>def __init__(\n    self,\n    name: str,\n    properties: MaterialParameters,\n    hamiltonian: SpinHamiltonian,\n    m_cell: float,\n    nodmi: bool = False,\n    noaniso: bool = False,\n):\n    \"\"\"\n    Constructor for a magnon material\n\n    In the current implementation, the hamiltonian only\n    contains the magnetic atoms and their interactions.\n    So m_cell needs to be specified separately\n\n    Args:\n        name: The name of the material.\n        properties: The properties of the material.\n        hamiltonian: The spin Hamiltonian\n        m_cell: the total mass of all ions in the cell\n        nodmi: Whether to include DM interactions.\n        noaniso: Whether to include anisotropic exchange.\n    \"\"\"\n    # Ensure the hamiltonian is in the correct units\n    # hamiltonian.cell *= const.Ang_to_inveV\n    # In the future we should have a check that it comes in in units of A\n    # And convert it here\n    self.hamiltonian = hamiltonian\n    n_atoms = len(hamiltonian.magnetic_atoms)\n    self.n_modes = n_atoms\n    self.dispersion = MagnonDispersion(\n        hamiltonian, phase_convention=\"tanner\", nodmi=nodmi, noaniso=noaniso\n    )\n\n    n_atoms = len(hamiltonian.magnetic_atoms)  # Number of magnetic atoms\n    properties.validate_for_magnons(n_atoms)\n    # Atom positions in cartesian coordinates (units of 1/eV)\n    self.xj = np.array(\n        [\n            hamiltonian.get_atom_coordinates(atom, relative=False)\n            for atom in hamiltonian.magnetic_atoms\n        ]\n    )\n    # sqrt(Sj/2)\n    # TODO: make this an internal variable\n    self.sqrt_spins_2 = np.sqrt(\n        np.array([atom.spin for atom in hamiltonian.magnetic_atoms]) / 2\n    )\n    # The vectors for rotating to local coordiante system\n    # TODO: make this an internal variable\n    self.rj = self.dispersion.u\n\n    positions = np.array([a.position for a in hamiltonian.magnetic_atoms])\n    lattice = hamiltonian.cell\n    species = [a.type for a in hamiltonian.magnetic_atoms]\n    structure = Structure(lattice, species, positions)\n\n    m_atoms = [m_cell / n_atoms] * n_atoms\n    super().__init__(name, properties, structure, m_atoms)\n</code></pre>"},{"location":"reference/darkmagic/material/#darkmagic.material.MagnonMaterial.max_dE","title":"<code>max_dE: float</code>  <code>property</code>","text":"<p>TODO: this needs improvement</p> <p>Returns the maximum dE possible for the material. For magnons, we estimate this as roughly 3 times the highest magnon frequency at the Brillouin zone (BZ) boundary. If there are no gapped modes at the gamma point, the maximum dE will be 0.</p> <p>Returns:</p> Name Type Description <code>float</code> <code>float</code> <p>The maximum dE value.</p> Notes <p>This calculation should be an average over the Brillouin zone (BZ).</p>"},{"location":"reference/darkmagic/material/#darkmagic.material.MagnonMaterial.q_cut","title":"<code>q_cut: float</code>  <code>property</code>","text":"<p>For magnons there is no <code>q_cut</code>, so we just set this to a very large number.</p> <p>Returns:</p> Name Type Description <code>q_cut</code> <code>float</code> <p>a very large number.</p>"},{"location":"reference/darkmagic/material/#darkmagic.material.MagnonMaterial.get_eig","title":"<code>get_eig(k, G)</code>","text":"<p>Calculate the eigenvalues and magnon polarization vectors for a given k-point and G-vector.</p> <p>Parameters:</p> Name Type Description Default <code>k</code> <code>ArrayLike</code> <p>Single k-point, cartesian coordinates (units of eV).</p> required <code>G</code> <code>ArrayLike</code> <p>Single G-vector, cartesian coordinates (units of eV).</p> required <p>Returns:</p> Type Description <code>Tuple[ndarray, ndarray]</code> <p>Tuple[np.ndarray, np.ndarray]: A tuple containing the eigenvalues (omega_nu_k) and eigenvectors (epsilon_nu_k_G). - omega_nu_k: (N,) an array of complex numbers representing the eigenvalues in eV. - epsilon_nu_k_G: (N,3) array of complex numbers representing the eigenvectors (magnon polarization vectors) in eV/?? N is the number of magnon modes.</p> Source code in <code>darkmagic/material.py</code> <pre><code>def get_eig(self, k: ArrayLike, G: ArrayLike) -&gt; Tuple[np.ndarray, np.ndarray]:\n    \"\"\"\n    Calculate the eigenvalues and magnon polarization vectors for a given k-point and G-vector.\n\n    Args:\n        k (ArrayLike): Single k-point, cartesian coordinates (units of eV).\n        G (ArrayLike): Single G-vector, cartesian coordinates (units of eV).\n\n    Returns:\n        Tuple[np.ndarray, np.ndarray]: A tuple containing the eigenvalues (omega_nu_k) and eigenvectors (epsilon_nu_k_G).\n            - omega_nu_k: (N,) an array of complex numbers representing the eigenvalues in eV.\n            - epsilon_nu_k_G: (N,3) array of complex numbers representing the eigenvectors (magnon polarization vectors) in eV/??\n            N is the number of magnon modes.\n\n    \"\"\"\n    # Calculate the prefactor\n    prefactor = self.sqrt_spins_2 * np.exp(1j * np.dot(self.xj, G))\n\n    # See Tanner's Disseration and RadTools doc for explanation of the 1/2\n    N = self.n_atoms\n    omega_nu_k, Tk = self._get_omega_T(self.dispersion.h(k) / 2)\n    Uk_conj = np.conjugate(Tk[:N, :N])  # This is U_{j,nu,k})*\n    V_minusk = np.conjugate(Tk[N:, :N])  # This is ((V_{j,nu,-k})*)*\n\n    epsilon_nu_k_G = (prefactor[:, None] * V_minusk).T @ np.conjugate(self.rj) + (\n        prefactor[:, None] * Uk_conj\n    ).T @ self.rj\n\n    return omega_nu_k, epsilon_nu_k_G  # (n,) and (n,3) array of complex numbers\n</code></pre>"},{"location":"reference/darkmagic/model/","title":"model","text":""},{"location":"reference/darkmagic/model/#darkmagic.model.Model","title":"<code>Model(name, coeff_prefactor, coeff_func, F_med_prop=None, ref_cross_sect=None, S_chi=0.5, shortname=None)</code>","text":"<p>A class representing a model for dark matter scattering. See the benchmark models for examples on how to define a model.</p> <p>Attributes:</p> Name Type Description <code>name</code> <code>str</code> <p>The name of the model.</p> <code>coeff_prefactor</code> <code>dict</code> <p>A dictionary of coefficient prefactors (constants).</p> <code>coeff_func</code> <code>dict</code> <p>A dictionary of coefficient functions of the form (grid, m_chi, S_chi) -&gt; np.array.</p> <code>F_med_prop</code> <code>Callable[[SphericalGrid], array]</code> <p>The mediator propagator</p> <code>power_V</code> <code>int</code> <p>The power V</p> <code>S_chi</code> <code>float</code> <p>The value of S_chi.</p> <code>operators</code> <code>dict</code> <p>A dictionary of operators.</p> <code>particles</code> <code>dict</code> <p>A dictionary of particles.</p> <p>Parameters:</p> Name Type Description Default <code>name</code> <code>str</code> <p>The name of the model.</p> required <code>coeff_prefactor</code> <code>dict</code> <p>A dictionary of coefficient prefactors.</p> required <code>coeff_func</code> <code>dict</code> <p>A dictionary of coefficient functions.</p> required <code>F_med_prop</code> <code>Callable[[SphericalGrid], array] | None</code> <p>A function that calculates the medium flux property. Defaults to None.</p> <code>None</code> <code>ref_cross_sect</code> <code>Callable[[array], array] | None</code> <p>A function that calculates the reference cross section. Defaults to None.</p> <code>None</code> <code>S_chi</code> <code>float</code> <p>DM spin, 1/2 by default.</p> <code>0.5</code> <code>shortname</code> <code>str</code> <p>The short name of the model, used in the output filenames. Defaults to lowercase initials of the model name.</p> <code>None</code> Source code in <code>darkmagic/model.py</code> <pre><code>def __init__(\n    self,\n    name: str,\n    coeff_prefactor: dict,\n    coeff_func: dict,\n    F_med_prop: Callable[[SphericalGrid], np.array] | None = None,\n    ref_cross_sect: Callable[[np.array], np.array] | None = None,\n    S_chi: float = 0.5,\n    shortname: str = None,\n):\n    \"\"\"\n    Constructor for the Model class.\n\n    Args:\n        name (str): The name of the model.\n        coeff_prefactor (dict): A dictionary of coefficient prefactors.\n        coeff_func (dict): A dictionary of coefficient functions.\n        F_med_prop (Callable[[SphericalGrid], np.array] | None, optional): A function that calculates the medium flux property. Defaults to None.\n        ref_cross_sect (Callable[[np.array], np.array] | None, optional): A function that calculates the reference cross section. Defaults to None.\n        S_chi (float, optional): DM spin, 1/2 by default.\n        shortname (str, optional): The short name of the model, used in the output filenames. Defaults to lowercase initials of the model name.\n    \"\"\"\n    self.name = name\n    if shortname is None:\n        shortname = \"\".join([word[0].lower() for word in name.split()])\n    self.shortname = shortname\n\n    self.S_chi = S_chi\n    self.coeff_prefactor = coeff_prefactor\n    self.coeff_func = coeff_func\n    self.operators, self.particles = self._get_operators_and_particles()\n\n    if F_med_prop is None:\n\n        def ones(grid):\n            return np.ones_like(grid.q_norm)\n\n        F_med_prop = ones\n    self.F_med_prop = F_med_prop\n\n    # Conversion factor to $\\bar{\\sigma}$ in NATURAL UNITS\n    if ref_cross_sect is None:\n\n        def ref_cross_sect(m_chi):\n            return np.ones_like(m_chi)\n\n        ref_cross_sect = ref_cross_sect\n\n    self.ref_cross_sect = ref_cross_sect\n\n    self._validate_coefficients()\n\n    # Unused, for backwards compatibility\n    self.Fmed_power = 0\n    self.power_V = 0\n</code></pre>"},{"location":"reference/darkmagic/model/#darkmagic.model.Model.get_unscreened_coeff","title":"<code>get_unscreened_coeff(alpha, psi, grid, m_chi, S_chi)</code>","text":"<p>Get the unscreened coefficient for a given (alpha, psi) pair.</p> <p>Parameters:</p> Name Type Description Default <code>alpha</code> <code>str</code> <p>The operator ID.</p> required <code>psi</code> <code>str</code> <p>The particle.</p> required <code>grid</code> <code>SphericalGrid</code> <p>The spherical grid.</p> required <code>m_chi</code> <code>float</code> <p>The dark matter mass.</p> required <code>S_chi</code> <code>float</code> <p>The dark matter spin.</p> required <p>Returns:</p> Type Description <code>float</code> <p>The unscreened coefficient \\(c_{\u0007lpha}^{(\\psi)}\\).</p> Source code in <code>darkmagic/model.py</code> <pre><code>def get_unscreened_coeff(\n    self, alpha: str, psi: str, grid: SphericalGrid, m_chi: float, S_chi: float\n) -&gt; float:\n    \"\"\"\n    Get the unscreened coefficient for a given (alpha, psi) pair.\n\n    Args:\n        alpha: The operator ID.\n        psi: The particle.\n        grid: The spherical grid.\n        m_chi: The dark matter mass.\n        S_chi: The dark matter spin.\n\n    Returns:\n        The unscreened coefficient $c_{\\alpha}^{(\\psi)}$.\n    \"\"\"\n    return self.coeff_prefactor[alpha][psi] * self.coeff_func[alpha][psi](\n        grid, m_chi, S_chi\n    )\n</code></pre>"},{"location":"reference/darkmagic/model/#darkmagic.model.Model.compute_screened_coeff","title":"<code>compute_screened_coeff(grid, epsilon, m_chi, S_chi)</code>","text":"<p>Compute the screened coefficients for every (operator, particle) pair.</p> <p>The screening of electron coefficients is done according to $$ c^{(e)}{\\alpha} \\rightarrow \\frac{c^{(e)}{\\alpha}}{\\hat{q} \\cdot (\\epsilon \\hat{q})} $$ and the proton coefficients $$ c^{(p)}{\\alpha} \\rightarrow c^{(p)}{\\alpha} + c^{(e)}_{\\alpha} \\left( 1 - \\frac{1}{\\hat{q} \\cdot (\\epsilon \\hat{q})} \\right) $$</p> <p>Parameters:</p> Name Type Description Default <code>grid</code> <code>SphericalGrid</code> <p>The SphericalGrid object containing all the momentum transfer vectors.</p> required <code>epsilon</code> <code>array</code> <p>The dielectric tensor.</p> required <code>m_chi</code> <code>float</code> <p>The dark matter mass.</p> required <code>S_chi</code> <code>float</code> <p>The dark matter spin.</p> required <p>Returns:</p> Type Description <code>dict</code> <p>A dictionary of the screened coefficients, indexable as alpha, with each element being a np.array of shape (nq,).</p> Source code in <code>darkmagic/model.py</code> <pre><code>def compute_screened_coeff(\n    self, grid: SphericalGrid, epsilon: np.array, m_chi: float, S_chi: float\n) -&gt; dict:\n    r\"\"\"\n    Compute the screened coefficients for every (operator, particle) pair.\n\n    The screening of electron coefficients is done according to\n    $$\n    c^{(e)}_{\\alpha} \\rightarrow \\frac{c^{(e)}_{\\alpha}}{\\hat{q} \\cdot (\\epsilon \\hat{q})}\n    $$\n    and the proton coefficients\n    $$\n    c^{(p)}_{\\alpha} \\rightarrow c^{(p)}_{\\alpha} + c^{(e)}_{\\alpha} \\left( 1 - \\frac{1}{\\hat{q} \\cdot (\\epsilon \\hat{q})} \\right)\n    $$\n\n    Args:\n        grid: The SphericalGrid object containing all the momentum transfer vectors.\n        epsilon: The dielectric tensor.\n        m_chi: The dark matter mass.\n        S_chi: The dark matter spin.\n\n    Returns:\n        A dictionary of the screened coefficients, indexable as [alpha][psi], with each element being a np.array of shape (nq,).\n    \"\"\"\n    q_eps_q = np.sum(grid.qhat_qhat * epsilon[None, :], axis=(-1, -2))\n    screened_coeff = {\n        alpha: {psi: self.coeff_prefactor[alpha][psi] for psi in self.particles}\n        for alpha in self.operators\n    }\n    for alpha, c_alpha in screened_coeff.items():\n        for psi in c_alpha.keys():\n            if psi == \"e\":\n                c_alpha[psi] *= 1 / q_eps_q\n            elif psi == \"p\":\n                # TODO: is this correct?\n                c_alpha[psi] += (1 - 1 / q_eps_q) * c_alpha.get(\"e\", 0)\n            elif psi == \"n\":\n                c_alpha[psi] *= np.ones_like(q_eps_q)\n            # neutrons are unscreened\n            c_alpha[psi] *= self.coeff_func[alpha][psi](grid, m_chi, S_chi)\n\n    return screened_coeff\n</code></pre>"},{"location":"reference/darkmagic/model/#darkmagic.model.Potential","title":"<code>Potential(model)</code>","text":"<p>Class for evaluating the potential for a given model.</p> <p>TODO: needs a good bit of cleanup and rethinking. Maybe this should be a subclass of model? TODO: all terms except V1_00 are written correctly but don't work with an array of q's as they should. (Painful) work in progress.</p> <p>Attributes:</p> Name Type Description <code>operators</code> <code>set</code> <p>The set of operators.</p> <code>particles</code> <code>set</code> <p>The set of particles.</p> <code>c</code> <code>Callable[[SphericalGrid, array, float, float], array]</code> <p>The function to compute the screened coefficients.</p> <code>needs_g1</code> <code>bool</code> <p>Whether the G1 velocity integrals are needed.</p> <code>needs_g2</code> <code>bool</code> <p>Whether the G2 velocity integrals are needed.</p> <p>Parameters:</p> Name Type Description Default <code>model</code> <code>Model</code> <p>The model for which to evaluate the potential.</p> required Source code in <code>darkmagic/model.py</code> <pre><code>def __init__(self, model: Model):\n    \"\"\"\n    Constructor for the Potential class.\n\n    Args:\n        model (Model): The model for which to evaluate the potential.\n    \"\"\"\n    self.operators = model.operators\n    self.particles = model.particles\n    self.c = model.compute_screened_coeff\n</code></pre>"},{"location":"reference/darkmagic/model/#darkmagic.model.Potential.eval_V","title":"<code>eval_V(grid, material, m_chi, S_chi)</code>","text":"<p>Evaluate the full potential V_j(q) for the given grid and material</p> <p>Parameters:</p> Name Type Description Default <code>grid</code> <code>SphericalGrid</code> <p>The grid of momentum transfer vectors.</p> required <code>material</code> <code>Material</code> <p>The material object</p> required <code>m_chi</code> <code>float</code> <p>The dark matter mass.</p> required <code>S_chi</code> <code>float</code> <p>The dark matter spin.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <code>dict</code> <p>A dictionary of the potential terms, indexed by the term type.</p> Source code in <code>darkmagic/model.py</code> <pre><code>def eval_V(\n    self, grid: SphericalGrid, material: Material, m_chi: float, S_chi: float\n) -&gt; dict:\n    \"\"\"\n    Evaluate the full potential V_j(q) for the given grid and material\n\n    Args:\n        grid (SphericalGrid): The grid of momentum transfer vectors.\n        material (Material): The material object\n        m_chi (float): The dark matter mass.\n        S_chi (float): The dark matter spin.\n\n    Returns:\n        dict: A dictionary of the potential terms, indexed by the term type.\n    \"\"\"\n\n    # Get all the V functions\n    full_V = self._get_full_V()\n\n    # Prepare the output dictionary\n    terms = {key for alpha in self.operators for key in full_V[alpha].keys()}\n    V = {t: self._get_zeros(t, material.n_atoms, grid) for t in terms}\n\n    # Determine which velocity integrals are needed\n    self.needs_g1 = bool(\"12\" or \"11\" in terms)\n    self.needs_g2 = \"20\" in terms\n\n    def get_slice(t):\n        return (slice(None),) + (None,) * (V[t].ndim - 1)\n\n    coeff = self.c(grid, material.epsilon, m_chi, S_chi)\n    # TODO: write this nicer\n    for psi in self.particles:\n        for alpha in self.operators:\n            C = coeff[alpha][psi]\n            for t, V_func in full_V[alpha].items():\n                V[t] += C[get_slice(t)] * V_func(grid, psi, material, m_chi, S_chi)\n    return V\n</code></pre>"},{"location":"reference/darkmagic/model/#darkmagic.model.MissingCoefficientFunctionException","title":"<code>MissingCoefficientFunctionException</code>","text":"<p>             Bases: <code>Exception</code></p> <p>Raised when an operator has a non-zero coefficient prefactor but no coefficient function.</p>"},{"location":"reference/darkmagic/model/#darkmagic.model.ExtraCoefficientFunctionWarning","title":"<code>ExtraCoefficientFunctionWarning</code>","text":"<p>             Bases: <code>Warning</code></p> <p>Warning that an operator has a coefficient function but no non-zero coefficient prefactor, so the operator will be ignored.</p>"},{"location":"reference/darkmagic/model/#darkmagic.model.UnsupportedOperatorException","title":"<code>UnsupportedOperatorException</code>","text":"<p>             Bases: <code>Exception</code></p> <p>Raised when an operator is not supported.</p>"},{"location":"reference/darkmagic/numerics/","title":"numerics","text":""},{"location":"reference/darkmagic/numerics/#darkmagic.numerics.MonkhorstPackGrid","title":"<code>MonkhorstPackGrid(N_grid, material, shift=True, use_sym=False)</code>","text":"<p>A class representing a Monkhorst-Pack grid for Brillouin zone sampling.</p> <p>Attributes:</p> Name Type Description <code>k_frac</code> <code>ndarray</code> <p>The fractional coordinates of the k vectors.</p> <code>weights</code> <code>ndarray</code> <p>The weights of the k vectors.</p> <p>N_grid (ArrayLike): The number of grid points along each reciprocal lattice vector. material (Material): The material for which the grid is generated. shift (bool): Whether to shift the grid. Defaults to a shifted grid to avoid singularities in DWF. use_sym (bool, optional): Whether to use symmetry to reduce the number of grid points. Defaults to False. The W tensor is only calculated once so this isn't necessary to use and causes issues.</p> Source code in <code>darkmagic/numerics.py</code> <pre><code>def __init__(\n    self,\n    N_grid: ArrayLike,\n    material: Material,\n    shift: bool = True,\n    use_sym: bool = False,\n):\n    \"\"\"\n    Constructor for the MonkhorstPackGrid class.\n\n    N_grid (ArrayLike): The number of grid points along each reciprocal lattice vector.\n    material (Material): The material for which the grid is generated.\n    shift (bool): Whether to shift the grid. Defaults to a shifted grid to avoid singularities in DWF.\n    use_sym (bool, optional): Whether to use symmetry to reduce the number of grid points. Defaults to False. The W tensor is only calculated once so this isn't necessary to use and causes issues.\n    \"\"\"\n    shift = [1, 1, 1] if shift else [0, 0, 0]\n    # SGA struggles with the struct in 1/eV, so we scale back to ang\n    struct = deepcopy(material.structure)\n    struct.scale_lattice(struct.volume * (const.inveV_to_Ang) ** 3)\n    sga = SpacegroupAnalyzer(struct)\n    if use_sym:\n        points = sga.get_ir_reciprocal_mesh(N_grid, is_shift=shift)\n        self.k_frac, self.weights = map(np.array, zip(*points))\n    else:\n        self.k_frac, _ = sga.get_ir_reciprocal_mesh_map(N_grid, is_shift=shift)\n        self.weights = np.ones_like(self.k_frac[:, 0])\n</code></pre>"},{"location":"reference/darkmagic/numerics/#darkmagic.numerics.SphericalGrid","title":"<code>SphericalGrid(m_chi, v_e, use_q_cut, N_grid, material)</code>","text":"<p>Represents a spherical grid used for numerical calculations in DarkMAGIC.</p> <p>Attributes:</p> Name Type Description <code>nq</code> <code>int</code> <p>The number of q points.</p> <code>q_max</code> <code>float</code> <p>The maximum value of the q vector (eV).</p> <code>q_cart</code> <code>ndarray</code> <p>The Cartesian coordinates of the q vectors (eV).</p> <code>q_frac</code> <code>ndarray</code> <p>The fractional coordinates of the q vectors.</p> <code>q_norm</code> <code>ndarray</code> <p>The norms of the q vectors (eV).</p> <code>q_hat</code> <code>ndarray</code> <p>The unit vectors of the q vectors.</p> <code>G_cart</code> <code>ndarray</code> <p>The Cartesian coordinates of the G vectors (eV).</p> <code>G_frac</code> <code>ndarray</code> <p>The fractional coordinates of the G vectors.</p> <code>jacobian</code> <code>ndarray</code> <p>The Jacobian determinant for the spherical grid.</p> <code>k_frac</code> <code>ndarray</code> <p>The fractional coordinates of the k vectors.</p> <code>k_cart</code> <code>ndarray</code> <p>The Cartesian coordinates of the k vectors.</p> <p>Parameters:</p> Name Type Description Default <code>m_chi</code> <code>float</code> <p>The mass of the dark matter particle.</p> required <code>v_e</code> <code>ArrayLike</code> <p>The velocity of the Earth.</p> required <code>use_q_cut</code> <code>bool</code> <p>Whether to use the q_cut value.</p> required <code>N_grid</code> <code>ArrayLike</code> <p>The number of grid points (radial, azimuthal, polar)</p> required <code>material</code> <code>Material</code> <p>A Material object containing the material properties.</p> required Source code in <code>darkmagic/numerics.py</code> <pre><code>def __init__(\n    self,\n    m_chi: float,\n    v_e: ArrayLike,\n    use_q_cut: bool,\n    N_grid: ArrayLike,\n    material: Material,\n):\n    \"\"\"\n    Spherical grid constructor.\n\n    Args:\n        m_chi: The mass of the dark matter particle.\n        v_e: The velocity of the Earth.\n        use_q_cut: Whether to use the q_cut value.\n        N_grid: The number of grid points (radial, azimuthal, polar)\n        material: A Material object containing the material properties.\n    \"\"\"\n    # Get q and G vectors\n    q_cut = material.q_cut if use_q_cut else 1e10\n    self.q_max = min(2 * m_chi * (const.VESC + const.VE), q_cut)\n    self.q_cart, self.q_frac = self._get_q_points(\n        N_grid, m_chi, v_e, material.recip_cart_to_frac\n    )\n    self.nq = self.q_cart.shape[0]\n    # These show up often so it's efficient to compute them only once\n    self.q_norm = LA.norm(self.q_cart, axis=1)\n    self.q_hat = self.q_cart / self.q_norm[:, None]\n\n    # Get G-vectors\n    self.G_cart, self.G_frac = self._get_G_vectors(material.recip_frac_to_cart)\n    # Deriving this is straightforward, remember we're sampling\n    # with a power of 2 in the q direction, hence the square roots on |q|\n    self.jacobian = 8 * np.pi * self.q_norm ** (5 / 2) * self.q_max ** (1 / 2)\n\n    # Get the k-vectors\n    self.k_frac = self.q_frac - self.G_frac\n    self.k_cart = np.matmul(self.k_frac, material.recip_frac_to_cart)\n\n    # Outer product of qhat with itself is frequently used\n    self._qhat_qhat = None\n</code></pre>"},{"location":"reference/darkmagic/numerics/#darkmagic.numerics.Numerics","title":"<code>Numerics(N_grid=None, power_abc=None, N_DWF_grid=None, bin_width=0.001, use_q_cut=True, use_special_mesh=False)</code>","text":"<p>A class that represents the numerical parameters for DarkMAGIC calculations.</p> <p>Parameters:</p> Name Type Description Default <code>N_grid</code> <code>ArrayLike</code> <p>The number of grid points in each dimension. Defaults to [20, 10, 10].</p> <code>None</code> <code>power_abc</code> <code>ArrayLike</code> <p>The power of each dimension in the grid. Defaults to [2, 1, 1].</p> <code>None</code> <code>N_DWF_grid</code> <code>ArrayLike</code> <p>The number of grid points in each dimension for the density-weighted Fermi grid. Defaults to [20, 20, 20].</p> <code>None</code> <code>bin_width</code> <code>float</code> <p>The width of the bin. Defaults to 1e-3 (1 meV).</p> <code>0.001</code> <code>use_q_cut</code> <code>bool</code> <p>Whether to use a cutoff in momentum space. Defaults to True.</p> <code>True</code> <code>use_special_mesh</code> <code>bool</code> <p>Whether to use a special mesh for the grid. Defaults to False.</p> <code>False</code> <p>Attributes:</p> Name Type Description <code>N_grid</code> <code>ndarray</code> <p>The number of grid points in the spherical grid used to sample the momentum transfer (radial, azimuthal, polar).</p> <code>power_abc</code> <code>ndarray</code> <p>The power of each dimension in the grid (currently unsued)</p> <code>N_DWF_grid</code> <code>ndarray</code> <p>The size of the Monkhorst-Pack grid used to compute the Debye-Waller factor.</p> <code>bin_width</code> <code>float</code> <p>The width of the energy bin. Rebinning to larger bins is possible in postprocessing.</p> <code>use_q_cut</code> <code>bool</code> <p>Whether to use a cutoff for the momentum transfer from DM. If False, the cutoff is set to the maximum possible value \\(2 m_{\\chi} (v_{\\text{esc}} + v_{\\text{e}})\\).</p> <code>use_special_mesh</code> <code>bool</code> <p>Whether to use a special mesh for the spherical grid (currently unused)</p> <p>Methods:</p> Name Description <code>get_grid</code> <p>float, v_e: ArrayLike, material: Material) -&gt; SphericalGrid: Returns the spherical grid for the given dark matter mass, Earth velocity, and material.</p> <code>get_DWF_grid</code> <p>Material) -&gt; MonkhorstPackGrid: Returns the Monkhorst-Pack grid for computing the Debye-Waller factor.</p> <p>Parameters:</p> Name Type Description Default <code>N_grid</code> <code>ndarray</code> <p>The number of grid points in the spherical grid used to sample the momentum transfer (radial, azimuthal, polar).</p> <code>None</code> <code>power_abc</code> <code>ndarray</code> <p>The power of each dimension in the grid (currently unsued)</p> <code>None</code> <code>N_DWF_grid</code> <code>ndarray</code> <p>The size of the Monkhorst-Pack grid used to compute the Debye-Waller factor.</p> <code>None</code> <code>bin_width</code> <code>float</code> <p>The width of the energy bin. Rebinning to larger bins is possible in postprocessing.</p> <code>0.001</code> <code>use_q_cut</code> <code>bool</code> <p>Whether to use a cutoff for the momentum transfer from DM. If False, the cutoff is set to the maximum possible value \\(2 m_{\\chi} (v_{\\text{esc}} + v_{\\text{e}})\\).</p> <code>True</code> <code>use_special_mesh</code> <code>bool</code> <p>Whether to use a special mesh for the spherical grid (currently unused)</p> <code>False</code> Source code in <code>darkmagic/numerics.py</code> <pre><code>def __init__(\n    self,\n    N_grid: ArrayLike = None,\n    power_abc: ArrayLike = None,\n    N_DWF_grid: ArrayLike = None,\n    bin_width: float = 1e-3,\n    use_q_cut: bool = True,\n    use_special_mesh: bool = False,\n):\n    r\"\"\"\n    Constructor for the Numerics class.\n\n    Args:\n        N_grid (ndarray): The number of grid points in the spherical grid used to sample the momentum transfer (radial, azimuthal, polar).\n        power_abc (ndarray): The power of each dimension in the grid (currently unsued)\n        N_DWF_grid (ndarray): The size of the Monkhorst-Pack grid used to compute the Debye-Waller factor.\n        bin_width (float): The width of the energy bin. Rebinning to larger bins is possible in postprocessing.\n        use_q_cut (bool): Whether to use a cutoff for the momentum transfer from DM. If False, the cutoff is set to the maximum possible value $2 m_{\\chi} (v_{\\text{esc}} + v_{\\text{e}})$.\n        use_special_mesh (bool): Whether to use a special mesh for the spherical grid (currently unused)\n    \"\"\"\n    if N_grid is None:\n        N_grid = [20, 10, 10]\n    if power_abc is None:\n        power_abc = [2, 1, 1]\n    if N_DWF_grid is None:\n        N_DWF_grid = [20, 20, 20]\n    self.N_grid = np.array(N_grid)\n    self.power_abc = np.array(power_abc)\n    self.N_DWF_grid = np.array(N_DWF_grid)\n    self.bin_width = bin_width\n    self.use_q_cut = use_q_cut\n    self.use_special_mesh = use_special_mesh\n</code></pre>"},{"location":"reference/darkmagic/numerics/#darkmagic.numerics.Numerics.get_grid","title":"<code>get_grid(m_chi, v_e, material)</code>","text":"<p>Returns the spherical grid object.</p> <p>Parameters:</p> Name Type Description Default <code>m_chi</code> <code>float</code> <p>The mass of the dark matter particle.</p> required <code>v_e</code> <code>ArrayLike</code> <p>The velocity of the Earth.</p> required <code>material</code> <code>Material</code> <p>The material object.</p> required <p>Returns:</p> Name Type Description <code>SphericalGrid</code> <code>SphericalGrid</code> <p>The spherical grid object.</p> Source code in <code>darkmagic/numerics.py</code> <pre><code>def get_grid(\n    self, m_chi: float, v_e: ArrayLike, material: Material\n) -&gt; SphericalGrid:\n    \"\"\"\n    Returns the spherical grid object.\n\n    Args:\n        m_chi (float): The mass of the dark matter particle.\n        v_e (ArrayLike): The velocity of the Earth.\n        material (Material): The material object.\n\n    Returns:\n        SphericalGrid: The spherical grid object.\n    \"\"\"\n    return SphericalGrid(m_chi, v_e, self.use_q_cut, self.N_grid, material)\n</code></pre>"},{"location":"reference/darkmagic/numerics/#darkmagic.numerics.Numerics.get_DWF_grid","title":"<code>get_DWF_grid(material)</code>","text":"<p>Returns the density-weighted Fermi grid object.</p> <p>Parameters:</p> Name Type Description Default <code>material</code> <code>Material</code> <p>The material object.</p> required <p>Returns:</p> Name Type Description <code>MonkhorstPackGrid</code> <code>MonkhorstPackGrid</code> <p>The density-weighted Fermi grid object.</p> Source code in <code>darkmagic/numerics.py</code> <pre><code>def get_DWF_grid(self, material: Material) -&gt; MonkhorstPackGrid:\n    \"\"\"\n    Returns the density-weighted Fermi grid object.\n\n    Args:\n        material (Material): The material object.\n\n    Returns:\n        MonkhorstPackGrid: The density-weighted Fermi grid object.\n    \"\"\"\n    return MonkhorstPackGrid(self.N_DWF_grid, material)\n</code></pre>"},{"location":"reference/darkmagic/parallel/","title":"parallel","text":""},{"location":"reference/darkmagic/parallel/#darkmagic.parallel.distribute_load","title":"<code>distribute_load(n_proc, masses, times)</code>","text":"<p>This function distributes the load of jobs across the available processors. It attempts to balance the load as much as possible.</p> Source code in <code>darkmagic/parallel.py</code> <pre><code>def distribute_load(n_proc, masses, times):\n    \"\"\"\n    This function distributes the load of jobs across the available processors.\n    It attempts to balance the load as much as possible.\n    \"\"\"\n    # TODO: change to logging\n    print(\"Distributing load among processors.\")\n    # Our jobs list is a list of tuples, where each tuple is a pair of (mass, time) indices\n    total_job_list = np.array(\n        list(itertools.product(range(len(masses)), range(len(times))))\n    )\n    n_jobs = len(total_job_list)\n\n    base_jobs_per_proc = n_jobs // n_proc  # each processor has at least this many jobs\n    extra_jobs = 1 if n_jobs % n_proc else 0  # might need 1 more job on some processors\n    # Note a fan of using a sentinel value to indicate a \"do nothing\" job\n    job_list = JOB_SENTINEL * np.ones(\n        (n_proc, base_jobs_per_proc + extra_jobs, 2), dtype=int\n    )\n\n    for i in range(n_jobs):\n        proc_index = i % n_proc\n        job_index = i // n_proc\n        job_list[proc_index, job_index] = total_job_list[i]\n\n    if n_jobs &gt; n_proc:\n        print(\"Number of jobs exceeds the number of processors.\")\n        print(f\"Baseline number of jobs per processor: {str(base_jobs_per_proc)}\")\n        print(\n            \"Remaining processors with one extra job: \"\n            + str(n_jobs - n_proc * base_jobs_per_proc)\n        )\n    elif n_jobs &lt; n_proc:\n        print(\"Number of jobs is fewer than the number of processors.\")\n        print(\"Consider reducing the number of processors for more efficiency.\")\n        print(f\"Total number of jobs: {n_jobs}\")\n    else:\n        print(\"Number of jobs matches the number of processors. Maximally parallized.\")\n\n    return job_list\n</code></pre>"},{"location":"reference/darkmagic/rate/","title":"rate","text":""},{"location":"reference/darkmagic/rate/#darkmagic.rate.Calculation","title":"<code>Calculation(m_chi, material, model, numerics, time=0, v_e=None)</code>","text":"<p>Generic class for calculating the differential rate</p> Source code in <code>darkmagic/rate.py</code> <pre><code>def __init__(\n    self,\n    m_chi: float,\n    material: MagnonMaterial,\n    model: Model,\n    numerics: Numerics,\n    time: float | None = 0,\n    v_e: ArrayLike | None = None,\n):\n    self.m_chi = m_chi\n    if time is None and v_e is None:\n        raise ValueError(\"Either time or v_e must be provided\")\n    if time is not None and v_e is not None:\n        raise ValueError(\"Only one of time or v_e should be provided\")\n    self.v_e = self.compute_ve(time) if time is not None else v_e\n    self.material = material\n    self.model = model\n    self.numerics = numerics\n    self.grid = numerics.get_grid(m_chi, self.v_e, material)\n    self.dwf_grid = numerics.get_DWF_grid(material)\n</code></pre>"},{"location":"reference/darkmagic/rate/#darkmagic.rate.Calculation.compute_ve","title":"<code>compute_ve(t)</code>","text":"<p>Returns the earth's velocity in the lab frame at time t (in hours)</p> Source code in <code>darkmagic/rate.py</code> <pre><code>def compute_ve(self, t: float):\n    \"\"\"\n    Returns the earth's velocity in the lab frame at time t (in hours)\n    \"\"\"\n    phi = 2 * np.pi * (t / 24.0)\n    theta = const.theta_earth\n\n    return const.VE * np.array(\n        [\n            np.sin(theta) * np.sin(phi),\n            np.cos(theta) * np.sin(theta) * (np.cos(phi) - 1),\n            (np.sin(theta) ** 2) * np.cos(phi) + np.cos(theta) ** 2,\n        ]\n    )\n</code></pre>"},{"location":"reference/darkmagic/rate/#darkmagic.rate.MagnonCalculation","title":"<code>MagnonCalculation(m_chi, material, model, numerics, time=0, v_e=None)</code>","text":"<p>             Bases: <code>Calculation</code></p> <p>Class for calculating the differential rate for magnon scattering</p> Source code in <code>darkmagic/rate.py</code> <pre><code>def __init__(\n    self,\n    m_chi: float,\n    material: MagnonMaterial,\n    model: Model,\n    numerics: Numerics,\n    time: float | None = 0,\n    v_e: ArrayLike | None = None,\n):\n    self.m_chi = m_chi\n    if time is None and v_e is None:\n        raise ValueError(\"Either time or v_e must be provided\")\n    if time is not None and v_e is not None:\n        raise ValueError(\"Only one of time or v_e should be provided\")\n    self.v_e = self.compute_ve(time) if time is not None else v_e\n    self.material = material\n    self.model = model\n    self.numerics = numerics\n    self.grid = numerics.get_grid(m_chi, self.v_e, material)\n    self.dwf_grid = numerics.get_DWF_grid(material)\n</code></pre>"},{"location":"reference/darkmagic/rate/#darkmagic.rate.MagnonCalculation.calculate_rate","title":"<code>calculate_rate()</code>","text":"<p>Computes the differential rate</p> Source code in <code>darkmagic/rate.py</code> <pre><code>def calculate_rate(\n    self,\n):\n    \"\"\"\n    Computes the differential rate\n    \"\"\"\n\n    max_bin_num = math.ceil(self.material.max_dE / self.numerics.bin_width)\n\n    n_modes = self.material.n_modes\n    n_q = len(self.grid.q_cart)\n\n    diff_rate = np.zeros(max_bin_num, dtype=complex)\n    binned_rate = np.zeros(n_modes, dtype=complex)\n    omegas = np.zeros((n_q, n_modes))\n    epsilons = np.zeros((n_q, n_modes, 3), dtype=complex)\n\n    model_name = self.model.name\n\n    # TODO: implement this without a loop?\n    for iq, (G, k) in enumerate(zip(self.grid.G_cart, self.grid.k_cart)):\n        if iq % 1000 == 0:\n            print(f\"* m_chi = {self.m_chi:13.4f}, q-point: {iq:6d}/{n_q:6d})\")\n        omegas[iq, :], epsilons[iq, :, :] = self.material.get_eig(k, G)\n\n    v_dist = MBDistribution(self.grid, omegas, self.m_chi, self.v_e)\n\n    # Along with omega and epsilons, these are all q*nu arrays\n    bin_num = np.floor((omegas) / self.numerics.bin_width).astype(int)\n    g0 = v_dist.G0\n\n    if model_name == \"Magnetic Dipole\":\n        sigma_nu_q = self.sigma_mdm(self.grid.q_cart, epsilons)\n    elif model_name == \"Anapole\":\n        sigma_nu_q = self.sigma_ap(self.grid.q_cart, epsilons)\n    else:\n        raise ValueError(\n            f\"Unknown model: {model_name}. Generic magnon models not yet implemented, only mdm and ap.\"\n        )\n    tiled_jacobian = np.tile(self.grid.jacobian, (n_modes, 1)).T\n\n    # Integrate to get deltaR\n    vol_element = tiled_jacobian * (\n        (2 * np.pi) ** 3 * np.prod(self.numerics.N_grid)\n    ) ** (-1)\n    deltaR = (\n        (1 / self.material.m_cell)\n        * (const.rho_chi / self.m_chi)\n        * vol_element\n        * sigma_nu_q\n        * g0\n    )\n\n    # Get diff rate, binned rate and total rate\n    diff_rate = np.zeros(max_bin_num)\n    np.add.at(diff_rate, bin_num, deltaR)\n    binned_rate = np.sum(deltaR, axis=0)\n    total_rate = sum(diff_rate)\n\n    return [diff_rate, binned_rate, total_rate]\n</code></pre>"},{"location":"reference/darkmagic/rate/#darkmagic.rate.PhononCalculation","title":"<code>PhononCalculation(m_chi, material, model, numerics, time=0, v_e=None)</code>","text":"<p>             Bases: <code>Calculation</code></p> <p>Class for calculating the differential rate for phonon scattering</p> Source code in <code>darkmagic/rate.py</code> <pre><code>def __init__(\n    self,\n    m_chi: float,\n    material: MagnonMaterial,\n    model: Model,\n    numerics: Numerics,\n    time: float | None = 0,\n    v_e: ArrayLike | None = None,\n):\n    self.m_chi = m_chi\n    if time is None and v_e is None:\n        raise ValueError(\"Either time or v_e must be provided\")\n    if time is not None and v_e is not None:\n        raise ValueError(\"Only one of time or v_e should be provided\")\n    self.v_e = self.compute_ve(time) if time is not None else v_e\n    self.material = material\n    self.model = model\n    self.numerics = numerics\n    self.grid = numerics.get_grid(m_chi, self.v_e, material)\n    self.dwf_grid = numerics.get_DWF_grid(material)\n</code></pre>"},{"location":"reference/darkmagic/rate/#darkmagic.rate.PhononCalculation.calculate_rate","title":"<code>calculate_rate()</code>","text":"<p>Computes the differential rate</p> Source code in <code>darkmagic/rate.py</code> <pre><code>def calculate_rate(\n    self,\n):\n    \"\"\"\n    Computes the differential rate\n    \"\"\"\n\n    max_bin_num = math.ceil(self.material.max_dE / self.numerics.bin_width)\n\n    n_modes = self.material.n_modes\n\n    diff_rate = np.zeros(max_bin_num, dtype=complex)\n    binned_rate = np.zeros(n_modes, dtype=complex)\n\n    # (nq, nmodes) and (nq, nmodes, natoms, 3)\n    omegas, epsilons = self.material.get_eig(self.grid.k_frac)\n    # (nq, na, 3, 3)\n    W_tensor = self.material.get_W_tensor(self.dwf_grid)\n\n    # W_j(q) = q_\\alpha W_\\alpha\\beta q_\\beta (DWF)\n    W_q_j = (\n        np.sum(\n            W_tensor[None, ...] * self.grid.qhat_qhat[:, None, ...], axis=(2, 3)\n        ).real\n        * self.grid.q_norm[:, None] ** 2\n    )\n    # exp(i G \\cdot x_j - W_j(q))\n    xj = self.material.structure.cart_coords\n    G = self.grid.G_cart\n    exponential = np.exp(1j * np.dot(G, xj.T) - W_q_j)  # (nq, na)\n\n    # q_\\alpha \\epsilon_{k \\nu j \\alpha}\n    q_dot_epsconj = np.sum(\n        self.grid.q_cart[:, None, None, :] * epsilons.conj(), axis=3\n    )  # (nq, nmodes, na)\n\n    # H(q)_{\\nu j} = e^{i G x_j} e^{- W_j(q)}  \\times\n    # \\frac{q \\cdot \\epsilon_{k j \\nu}^*}{\\sqrt{2 m_j \\omega_{k \\nu}}\n    H_q_nu_j = (exponential[:, None, :] * q_dot_epsconj) / np.sqrt(\n        2 * self.material.m_atoms[None, None, :] * omegas[..., None]\n    )\n    # TODO: better way to deal with this.\n    # We get issues from the very small negative frequencies very close to Gamma\n    # Which we're not avoiding since I don't want to put a build in threshold.\n    H_q_nu_j = np.nan_to_num(H_q_nu_j)\n\n    # Compute potential\n    pot = Potential(self.model)\n    V_q_j = pot.eval_V(self.grid, self.material, self.m_chi, self.model.S_chi)\n\n    # H(q)_{\\nu j'}^* \\times H(q)_{\\nu j}\n    Hs_jp_H_j = H_q_nu_j.conj()[..., None] * H_q_nu_j[..., None, :]\n    # (V^{00}_{j'}(q))^* \\times V^{00}_{j}(q)\n    V00s_jp_V00_j = V_q_j[\"00\"].conj()[..., None] * V_q_j[\"00\"][..., None, :]\n    # \\Sigma^0_{\\nu}(q)=\\sum_{jj'} H(q)_{\\nu j'}^* H(q)_{\\nu j} V_{00 j'}^* V_{00 j}\n    sigma0_q_nu = np.sum(Hs_jp_H_j * V00s_jp_V00_j[:, None, ...], axis=(2, 3)).real\n    # sigma0_q_nu = np.abs(np.sum((H_q_nu_j * V_q_j[\"00\"][:, None, ...]), axis=2))**2\n\n    # Now we need the maxwell boltzmann distribution\n    v_dist = MBDistribution(self.grid, omegas, self.m_chi, self.v_e)\n    G0 = v_dist.G0\n\n    # Integrate to get deltaR\n    tiled_jacobian = np.tile(self.grid.jacobian, (n_modes, 1)).T\n    vol_element = tiled_jacobian * (\n        (2 * np.pi) ** 3 * np.prod(self.numerics.N_grid)\n    ) ** (-1)\n    deltaR = (\n        (1 / self.material.m_cell)\n        * (const.rho_chi / self.m_chi)\n        * vol_element\n        * self.model.F_med_prop(self.grid)[:, None] ** 2\n        * (sigma0_q_nu * G0)\n    )\n    # Get diff rate, binned rate and total rate\n    bin_num = np.floor((omegas) / self.numerics.bin_width).astype(int)\n    diff_rate = np.zeros(max_bin_num)\n    np.add.at(diff_rate, bin_num, deltaR)\n    binned_rate = np.sum(deltaR, axis=0)\n    total_rate = np.sum(diff_rate)\n\n    return [diff_rate, binned_rate, total_rate]\n</code></pre>"},{"location":"reference/darkmagic/v_integrals/","title":"v_integrals","text":""},{"location":"reference/darkmagic/v_integrals/#darkmagic.v_integrals.MBDistribution","title":"<code>MBDistribution(grid, omega, m_chi, v_e)</code>","text":"<p>Class for truncated Maxwell-Boltzmann distribution</p> Source code in <code>darkmagic/v_integrals.py</code> <pre><code>def __init__(self, grid, omega, m_chi, v_e) -&gt; None:\n    self.grid = grid\n    self.omega = omega\n    self.m_chi = m_chi\n    self.v_e = np.array(v_e)\n\n    # Internal variables\n    self._v_minus = None\n    self._G0 = None\n    self._G1 = None\n    self._G2 = None\n    self._F = None\n    self._X = None\n    self._eye_minus_qhat_qhat = None\n</code></pre>"},{"location":"reference/darkmagic/v_integrals/#darkmagic.v_integrals.MBDistribution.v_minus","title":"<code>v_minus</code>  <code>property</code>","text":"<p>Computes v_minus = min(|v_star|, Vesc) for each (q, omega) pair q: numpy array of shape (n_q, 3), momentum transfer omega: 2D numpy array of shape (n_q, n_modes), eigenmodes m_chi: float, DM mass v_e: vector, lab frame velocity of earth</p>"},{"location":"reference/darkmagic/v_integrals/#darkmagic.v_integrals.MBDistribution.G0","title":"<code>G0</code>  <code>property</code>","text":"<p>Computes the G0 integral for each (q, omega) pair See Eq. C9 in EFT paper (2009.13534)</p>"},{"location":"reference/darkmagic/v_integrals/#darkmagic.v_integrals.MBDistribution.G1","title":"<code>G1</code>  <code>property</code>","text":"<p>Computes the g1 integral for each (q, omega) pair. See Eq. C11 in EFT paper (2009.13534). Note that my definition here is slightly different from that equation. See formalism notes.</p> <p>TODO: update this docstring with all the equations.</p> <p>The result is a 3D array of shape (n_q, n_modes, 3) (i.e., for each q-point and mode, we get a 3-vector)</p> <p>This integral is equivalent to</p> \\[ g1 = (v_star \\hat{q} - v_e - \\vec{q}/2/m_chi) * g0 \\] this is defined slightly differently in the original <p>PhonoDark. Specifically,</p> \\[ g1 = (v_star R[:,2] - v_e) * g0 \\] <p>where R is a matrix that rotates \\hat{q} to lie along the z-axis</p>"},{"location":"reference/darkmagic/v_integrals/#darkmagic.v_integrals.MBDistribution.G2","title":"<code>G2</code>  <code>property</code>","text":"<p>Computes the g2 integral for each (q, omega) pair. See Eq. C14 in EFT paper (2009.13534). Note that my definition here is slightly different, see the formalism notes.</p> <p>TODO: update this with all the equations</p> <p>The result is a 4D array of shape (n_q, n_modes, 3, 3) (i.e., for each q-point and mode, we get a 3x3 matrix)</p> <p>This suffers from a similar problem to g1, the definition in PhonoDark is quite different from the paper (including the definition of what I call F below) and I don't know how to reconcile them. It also invovles a rotation, like in g1.</p>"},{"location":"reference/darkmagic/v_integrals/#darkmagic.v_integrals.MBDistribution.F","title":"<code>F</code>  <code>property</code>","text":"<p>Computes the very last term of Eq. (C14) in the EFT paper (2009.13534) This is the term that multiplies (1 - qhat \\otimes qhat) in the g2 integral</p>"},{"location":"reference/darkmagic/v_integrals/#darkmagic.v_integrals.MBDistribution.X","title":"<code>X</code>  <code>property</code>","text":"<p>Computes the X vector for each (q, omega) pair</p> \\[ X = (\\omega / |q|) \\hat{q} - (\\mathbb{1} - \\hat{q} \\otimes \\hat{q}) v_e \\] <p>The result is a 3D array of shape (n_q, n_modes, 3)</p>"},{"location":"reference/darkmagic/v_integrals/#darkmagic.v_integrals.MBDistribution.eye_minus_qhat_qhat","title":"<code>eye_minus_qhat_qhat</code>  <code>property</code>","text":"<p>Computes the (3x3) matrix (1 - qhat \\otimes qhat) for each q-point The result is a 3D array of shape (n_q, 3, 3)</p>"},{"location":"reference/darkmagic/benchmark_models/","title":"benchmark_models","text":""},{"location":"reference/darkmagic/benchmark_models/anapole/","title":"anapole","text":""},{"location":"reference/darkmagic/benchmark_models/anapole/#darkmagic.benchmark_models.anapole.get_model","title":"<code>get_model()</code>","text":"<p>TODO: Add docstring.</p> Source code in <code>darkmagic/benchmark_models/anapole.py</code> <pre><code>def get_model() -&gt; Model:\n    \"\"\"\n    TODO: Add docstring.\n    \"\"\"\n    coeff_prefactor = {\n        \"8a\": {\n            \"e\": 1 / 2,  # factor of 1/2 in paper\n            \"p\": -1 / 2,  # Factor of 1/2 in paper * (-1)\n        },\n        \"8b\": {\n            \"e\": 1 / 2,  # factor of 1/2 in paper\n            \"p\": -1 / 2,  # Factor of 1/2 in paper * (-1)\n        },\n        \"9\": {\n            \"e\": -const.mu_tilde_e / 2,  # -mu_tilde_e/2\n            \"p\": const.mu_tilde_p / 2,  # -mu_tilde_p/2 * (-1)\n        },\n    }\n\n    coeff_func = {\n        \"8a\": {\"e\": q_sq_on_mchi_sq, \"p\": q_sq_on_mchi_sq},\n        \"8b\": {\"e\": q_sq_on_mchi_sq, \"p\": q_sq_on_mchi_sq},\n        \"9\": {\"e\": q_sq_on_mchi_sq, \"p\": q_sq_on_mchi_sq},\n    }\n\n    def reference_cross_section(m_chi: float) -&gt; float:\n        return (\n            np.pi\n            / 6\n            * 1\n            / (const.alphaEM**2 * const.m_e**2 * reduced_mass(m_chi, const.m_e) ** 2)\n        )\n\n    return Model(\"Anapole\", coeff_prefactor, coeff_func)\n</code></pre>"},{"location":"reference/darkmagic/benchmark_models/hadrophilic_scalar_mediator/","title":"hadrophilic_scalar_mediator","text":""},{"location":"reference/darkmagic/benchmark_models/hadrophilic_scalar_mediator/#darkmagic.benchmark_models.hadrophilic_scalar_mediator.get_model","title":"<code>get_model(mass)</code>","text":"<p>TODO: Add docstring.</p> Source code in <code>darkmagic/benchmark_models/hadrophilic_scalar_mediator.py</code> <pre><code>def get_model(mass: str) -&gt; Model:\n    \"\"\"\n    TODO: Add docstring.\n    \"\"\"\n    coeff_prefactor = {\n        \"1\": {\"e\": 0, \"p\": 1, \"n\": 1},\n    }\n\n    coeff_func = {\n        \"1\": {\"p\": one, \"n\": one},\n    }\n\n    if mass == \"heavy\":\n\n        def F_mediator_propagator(grid: SphericalGrid) -&gt; np.array:\n            return np.ones_like(grid.q_norm)\n\n        def reference_cross_section(m_chi: np.array) -&gt; np.array:\n            return np.pi * reduced_mass(m_chi, const.m_n) ** (-2)\n    elif mass == \"light\":\n\n        def F_mediator_propagator(grid: SphericalGrid) -&gt; np.array:\n            return grid.q_norm ** (-2)\n\n        def reference_cross_section(m_chi: np.array) -&gt; np.array:\n            q0 = m_chi * const.V0\n            return np.pi * reduced_mass(m_chi, const.m_n) ** (-2) * (q0) ** 4\n\n    else:\n        raise ValueError(\n            \"Unknown mass for the hadrophilic scalar mediator. \"\n            \"Only 'light' and 'heavy' are supported.\"\n        )\n\n    return Model(\n        f\"{mass.capitalize()} Hadrophilic Scalar Mediator\",\n        coeff_prefactor,\n        coeff_func,\n        F_mediator_propagator,\n        reference_cross_section,\n        shortname=f\"{mass[0]}sm\",\n    )\n</code></pre>"},{"location":"reference/darkmagic/benchmark_models/magnetic_dipole/","title":"magnetic_dipole","text":""},{"location":"reference/darkmagic/benchmark_models/magnetic_dipole/#darkmagic.benchmark_models.magnetic_dipole.get_model","title":"<code>get_model()</code>","text":"<p>TODO: Add docstring.</p> Source code in <code>darkmagic/benchmark_models/magnetic_dipole.py</code> <pre><code>def get_model() -&gt; Model:\n    \"\"\"\n    TODO: Add docstring.\n    \"\"\"\n    coeff_prefactor = {\n        \"1\": {\"e\": 1 / 4, \"p\": -1 / 4, \"n\": 0},\n        \"4\": {\"e\": const.mu_tilde_e, \"p\": -const.mu_tilde_p, \"n\": 0},\n        \"5a\": {\"e\": 1, \"p\": -1, \"n\": 0},\n        \"5b\": {\"e\": 1, \"p\": -1, \"n\": 0},\n        \"6\": {\"e\": -const.mu_tilde_e, \"p\": const.mu_tilde_p, \"n\": 0},\n    }\n\n    coeff_func = {\n        \"1\": {\"e\": q_sq_on_mchi_sq, \"p\": q_sq_on_mchi_sq},\n        \"4\": {\"e\": q_sq_on_mchi_me, \"p\": q_sq_on_mchi_mp},\n        \"5a\": {\"e\": me_on_mchi, \"p\": mp_on_mchi},\n        \"5b\": {\"e\": me_on_mchi, \"p\": mp_on_mchi},\n        \"6\": {\"e\": me_on_mchi, \"p\": mp_on_mchi},\n    }\n\n    def reference_cross_section(m_chi: float) -&gt; float:\n        return (\n            np.pi\n            * (m_chi + const.m_e) ** 2\n            / (6 * m_chi**2 + const.m_e**2)\n            / const.m_e**2\n        )\n\n    return Model(\n        \"Magnetic Dipole\",\n        coeff_prefactor,\n        coeff_func,\n        ref_cross_sect=reference_cross_section,\n    )\n</code></pre>"},{"location":"reference/darkmagic/benchmark_models/utils/","title":"utils","text":""},{"location":"reference/darkmagic/materials/","title":"materials","text":""},{"location":"reference/darkmagic/materials/VBTS_Magnon/","title":"VBTS_Magnon","text":""},{"location":"reference/darkmagic/materials/YIG_Magnon/","title":"YIG_Magnon","text":""}]}